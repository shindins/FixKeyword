<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>vector</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// vector standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _VECTOR_
#define _VECTOR_
#include &lt;yvals_core.h&gt;
#if _STL_COMPILER_PREPROCESSOR
#include &lt;__msvc_bit_utils.hpp&gt;
#include &lt;__msvc_sanitizer_annotate_container.hpp&gt;
#include &lt;xmemory&gt;

#if _HAS_CXX17
#include &lt;xpolymorphic_allocator.h&gt;
#endif // _HAS_CXX17

#if _HAS_CXX23
#include &lt;__msvc_formatter.hpp&gt;
#endif // _HAS_CXX23

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template &lt;class _Myvec&gt;
class _Vector_const_iterator : public _Iterator_base {
public:
#if _HAS_CXX20
    using iterator_concept = contiguous_iterator_tag;
#endif // _HAS_CXX20
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::const_pointer;
    using reference         = const value_type&amp;;

    using _Tptr = typename _Myvec::pointer;

    _CONSTEXPR20 _Vector_const_iterator() noexcept : _Ptr() {}

<span style = "background-color:#fdd">    _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {
        this-&gt;_Adopt(_Pvector);
    }</span>

    _NODISCARD _CONSTEXPR20 reference operator*() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
        _STL_VERIFY(_Mycont, "can't dereference invalidated vector iterator");
        _STL_VERIFY(
            _Mycont-&gt;_Myfirst &lt;= _Ptr &amp;&amp; _Ptr &lt; _Mycont-&gt;_Mylast, "can't dereference out of range vector iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return *_Ptr;
    }

    _NODISCARD _CONSTEXPR20 pointer operator-&gt;() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
        _STL_VERIFY(_Mycont, "can't dereference invalidated vector iterator");
        _STL_VERIFY(
            _Mycont-&gt;_Myfirst &lt;= _Ptr &amp;&amp; _Ptr &lt; _Mycont-&gt;_Mylast, "can't dereference out of range vector iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Ptr;
    }

    _CONSTEXPR20 _Vector_const_iterator&amp; operator++() noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
        _STL_VERIFY(_Mycont, "can't increment invalidated vector iterator");
        _STL_VERIFY(_Ptr &lt; _Mycont-&gt;_Mylast, "can't increment vector iterator past end");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        ++_Ptr;
        return *this;
    }

    _CONSTEXPR20 _Vector_const_iterator operator++(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _CONSTEXPR20 _Vector_const_iterator&amp; operator--() noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Ptr, "can't decrement value-initialized vector iterator");
        _STL_VERIFY(_Mycont, "can't decrement invalidated vector iterator");
        _STL_VERIFY(_Mycont-&gt;_Myfirst &lt; _Ptr, "can't decrement vector iterator before begin");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        --_Ptr;
        return *this;
    }

    _CONSTEXPR20 _Vector_const_iterator operator--(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    _CONSTEXPR20 void _Verify_offset(const difference_type _Off) const noexcept {
#if _ITERATOR_DEBUG_LEVEL == 0
        (void) _Off;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
        _STL_VERIFY(_Off == 0 || _Mycont, "cannot seek invalidated vector iterator");
        if (_Off &lt; 0) {
            _STL_VERIFY(_Off &gt;= _Mycont-&gt;_Myfirst - _Ptr, "cannot seek vector iterator before begin");
        }

        if (_Off &gt; 0) {
            _STL_VERIFY(_Off &lt;= _Mycont-&gt;_Mylast - _Ptr, "cannot seek vector iterator after end");
        }
#endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
    }

    _CONSTEXPR20 _Vector_const_iterator&amp; operator+=(const difference_type _Off) noexcept {
        _Verify_offset(_Off);
        _Ptr += _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR20 _Vector_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    _NODISCARD friend _CONSTEXPR20 _Vector_const_iterator operator+(
        const difference_type _Off, _Vector_const_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    _CONSTEXPR20 _Vector_const_iterator&amp; operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    _NODISCARD _CONSTEXPR20 _Vector_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20 difference_type operator-(const _Vector_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return static_cast&lt;difference_type&gt;(_Ptr - _Right._Ptr);
    }

    _NODISCARD _CONSTEXPR20 reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    _NODISCARD _CONSTEXPR20 bool operator==(const _Vector_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }

#if _HAS_CXX20
    _NODISCARD constexpr strong_ordering operator&lt;=&gt;(const _Vector_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return _STD _Unfancy_maybe_null(_Ptr) &lt;=&gt; _STD _Unfancy_maybe_null(_Right._Ptr);
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD bool operator!=(const _Vector_const_iterator&amp; _Right) const noexcept {
        return !(*this == _Right);
    }

    _NODISCARD bool operator&lt;(const _Vector_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return _Ptr &lt; _Right._Ptr;
    }

    _NODISCARD bool operator&gt;(const _Vector_const_iterator&amp; _Right) const noexcept {
        return _Right &lt; *this;
    }

    _NODISCARD bool operator&lt;=(const _Vector_const_iterator&amp; _Right) const noexcept {
        return !(_Right &lt; *this);
    }

    _NODISCARD bool operator&gt;=(const _Vector_const_iterator&amp; _Right) const noexcept {
        return !(*this &lt; _Right);
    }
#endif // ^^^ !_HAS_CXX20 ^^^

    _CONSTEXPR20 void _Compat(const _Vector_const_iterator&amp; _Right) const noexcept {
        // test for compatible iterator pair
#if _ITERATOR_DEBUG_LEVEL == 0
        (void) _Right;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
        _STL_VERIFY(this-&gt;_Getcont() == _Right._Getcont(), "vector iterators incompatible");
#endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
    }

#if _ITERATOR_DEBUG_LEVEL != 0
    friend _CONSTEXPR20 void _Verify_range(
<span style = "background-color:#fdd">        const _Vector_const_iterator&amp; _First, const _Vector_const_iterator&amp; _Last) noexcept {
        _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "vector iterators in range are from different containers");
        _STL_VERIFY(_First._Ptr &lt;= _Last._Ptr, "vector iterator range transposed");
    }</span>
#endif // _ITERATOR_DEBUG_LEVEL != 0

    using _Prevent_inheriting_unwrap = _Vector_const_iterator;

    _NODISCARD _CONSTEXPR20 const value_type* _Unwrapped() const noexcept {
        return _STD _Unfancy_maybe_null(_Ptr);
    }

    _CONSTEXPR20 void _Seek_to(const value_type* _It) noexcept {
        _Ptr = _STD _Refancy_maybe_null&lt;_Tptr&gt;(const_cast&lt;value_type*&gt;(_It));
    }

    _Tptr _Ptr; // pointer to element in vector
};

#if _HAS_CXX20
template &lt;class _Myvec&gt;
struct pointer_traits&lt;_Vector_const_iterator&lt;_Myvec&gt;&gt; {
    using pointer         = _Vector_const_iterator&lt;_Myvec&gt;;
    using element_type    = const pointer::value_type;
    using difference_type = pointer::difference_type;

    _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        // A value-initialized iterator is in the domain of to_address. An invalidated end iterator for a vector with
        // capacity() of 0 is not. This function cannot distinguish those two cases, so it incorrectly does not diagnose
        // the latter. In practice, this isn't a significant problem since to_address returns nullptr for such an
        // iterator.
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(_Iter._Getcont());
        if (_Mycont) {
            _STL_VERIFY(_Mycont-&gt;_Myfirst &lt;= _Iter._Ptr &amp;&amp; _Iter._Ptr &lt;= _Mycont-&gt;_Mylast,
                "can't convert out-of-range vector iterator to pointer");
        } else {
            _STL_VERIFY(!_Iter._Ptr, "can't convert invalid vector iterator to pointer");
        }
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _STD to_address(_Iter._Ptr);
    }
};
#endif // _HAS_CXX20

template &lt;class _Myvec&gt;
class _Vector_iterator : public _Vector_const_iterator&lt;_Myvec&gt; {
public:
    using _Mybase = _Vector_const_iterator&lt;_Myvec&gt;;

#if _HAS_CXX20
    using iterator_concept = contiguous_iterator_tag;
#endif // _HAS_CXX20
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::pointer;
    using reference         = value_type&amp;;

    using _Mybase::_Mybase;

    _NODISCARD _CONSTEXPR20 reference operator*() const noexcept {
        return const_cast&lt;reference&gt;(_Mybase::operator*());
    }

    _NODISCARD _CONSTEXPR20 pointer operator-&gt;() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(this-&gt;_Ptr, "can't dereference value-initialized vector iterator");
        _STL_VERIFY(_Mycont, "can't dereference invalidated vector iterator");
        _STL_VERIFY(_Mycont-&gt;_Myfirst &lt;= this-&gt;_Ptr &amp;&amp; this-&gt;_Ptr &lt; _Mycont-&gt;_Mylast,
            "can't dereference out of range vector iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return this-&gt;_Ptr;
    }

    _CONSTEXPR20 _Vector_iterator&amp; operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    _CONSTEXPR20 _Vector_iterator operator++(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _CONSTEXPR20 _Vector_iterator&amp; operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _CONSTEXPR20 _Vector_iterator operator--(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    _CONSTEXPR20 _Vector_iterator&amp; operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    _NODISCARD _CONSTEXPR20 _Vector_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    _NODISCARD friend _CONSTEXPR20 _Vector_iterator operator+(
        const difference_type _Off, _Vector_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    _CONSTEXPR20 _Vector_iterator&amp; operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    _NODISCARD _CONSTEXPR20 _Vector_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20 reference operator[](const difference_type _Off) const noexcept {
        return const_cast&lt;reference&gt;(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _Vector_iterator;

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {
        return _STD _Unfancy_maybe_null(this-&gt;_Ptr);
    }</span>
};

#if _HAS_CXX20
template &lt;class _Myvec&gt;
struct pointer_traits&lt;_Vector_iterator&lt;_Myvec&gt;&gt; {
    using pointer         = _Vector_iterator&lt;_Myvec&gt;;
    using element_type    = pointer::value_type;
    using difference_type = pointer::difference_type;

    _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        // A value-initialized iterator is in the domain of to_address. An invalidated end iterator for a vector with
        // capacity() of 0 is not. This function cannot distinguish those two cases, so it incorrectly does not diagnose
        // the latter. In practice, this isn't a significant problem since to_address returns nullptr for such an
        // iterator.
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(_Iter._Getcont());
        if (_Mycont) {
            _STL_VERIFY(_Mycont-&gt;_Myfirst &lt;= _Iter._Ptr &amp;&amp; _Iter._Ptr &lt;= _Mycont-&gt;_Mylast,
                "can't convert out-of-range vector iterator to pointer");
        } else {
            _STL_VERIFY(!_Iter._Ptr, "can't convert invalid vector iterator to pointer");
        }
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _STD to_address(_Iter._Ptr);
    }
};
#endif // _HAS_CXX20

template &lt;class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer&gt;
struct _Vec_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

struct _Value_init_tag { // tag to request value-initialization
    explicit _Value_init_tag() = default;
};

template &lt;class _Val_types&gt;
class _Vector_val : public _Container_base {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&amp;;
    using const_reference = const value_type&amp;;

<span style = "background-color:#fdd">    _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}</span>

    _CONSTEXPR20 _Vector_val(pointer _First, pointer _Last, pointer _End) noexcept
        : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

#if _MSVC_STL_DESTRUCTOR_TOMBSTONES
    _CONSTEXPR20 ~_Vector_val() noexcept {
        if constexpr (is_pointer_v&lt;pointer&gt;) {
            if (!_STD _Is_constant_evaluated()) {
                const auto _Tombstone{reinterpret_cast&lt;pointer&gt;(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
                _Myfirst = _Tombstone;
                _Mylast  = _Tombstone;
                _Myend   = _Tombstone;
            }
        }
    }
#endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES

    _CONSTEXPR20 void _Swap_val(_Vector_val&amp; _Right) noexcept {
        this-&gt;_Swap_proxy_and_iterators(_Right);
        swap(_Myfirst, _Right._Myfirst); // intentional ADL
        swap(_Mylast, _Right._Mylast); // intentional ADL
        swap(_Myend, _Right._Myend); // intentional ADL
    }

    _CONSTEXPR20 void _Take_contents(_Vector_val&amp; _Right) noexcept {
        this-&gt;_Swap_proxy_and_iterators(_Right);
        _Myfirst = _Right._Myfirst;
        _Mylast  = _Right._Mylast;
        _Myend   = _Right._Myend;

        _Right._Myfirst = nullptr;
        _Right._Mylast  = nullptr;
        _Right._Myend   = nullptr;
    }

    pointer _Myfirst; // pointer to beginning of array
    pointer _Mylast; // pointer to current end of sequence
    pointer _Myend; // pointer to end of array
};

_EXPORT_STD template &lt;class _Ty, class _Alloc = allocator&lt;_Ty&gt;&gt;
class vector { // varying size array of values
private:
    template &lt;class&gt;
    friend class _Vb_val;
    friend _Tidy_guard&lt;vector&gt;;

    using _Alty        = _Rebind_alloc_t&lt;_Alloc, _Ty&gt;;
    using _Alty_traits = allocator_traits&lt;_Alty&gt;;

public:
    static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v&lt;_Ty, typename _Alloc::value_type&gt;,
        _MISMATCHED_ALLOCATOR_MESSAGE("vector&lt;T, Allocator&gt;", "T"));
    static_assert(is_object_v&lt;_Ty&gt;, "The C++ Standard forbids containers of non-object types "
                                    "because of [container.requirements].");

    using value_type      = _Ty;
    using allocator_type  = _Alloc;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = _Ty&amp;;
    using const_reference = const _Ty&amp;;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;

private:
#ifdef _INSERT_VECTOR_ANNOTATION
    _CONSTEXPR20 void _Create_annotation() const noexcept {
        // Annotates the shadow memory of the valid range
        auto&amp; _My_data = _Mypair._Myval2;
        _Apply_annotation(_My_data._Myfirst, _My_data._Myend, _My_data._Myend, _My_data._Mylast);
    }

    _CONSTEXPR20 void _Remove_annotation() const noexcept {
        // Removes the shadow memory annotation of the range
        auto&amp; _My_data = _Mypair._Myval2;
        _Apply_annotation(_My_data._Myfirst, _My_data._Myend, _My_data._Mylast, _My_data._Myend);
    }

    _CONSTEXPR20 void _Modify_annotation(const difference_type _Count) const noexcept {
        // Extends/shrinks the annotated range by _Count
        if (_Count == 0) { // nothing to do
            // This also avoids calling _Apply_annotation() with null pointers
            // when the vector has zero capacity, see GH-2464.
            return;
        }

        auto&amp; _My_data = _Mypair._Myval2;
        _Apply_annotation(_My_data._Myfirst, _My_data._Myend, _My_data._Mylast, _My_data._Mylast + _Count);
    }

    static _CONSTEXPR20 void _Apply_annotation(
        pointer _First_, pointer _End_, pointer _Old_last_, pointer _New_last_) noexcept {
        _STL_INTERNAL_CHECK(_First_ != nullptr);
        _STL_INTERNAL_CHECK(_End_ != nullptr);
        _STL_INTERNAL_CHECK(_Old_last_ != nullptr);
        _STL_INTERNAL_CHECK(_New_last_ != nullptr);

        if constexpr (!_Disable_ASan_container_annotations_for_allocator&lt;allocator_type&gt;) {
#if _HAS_CXX20
            if (_STD is_constant_evaluated()) {
                return;
            }
#endif // _HAS_CXX20

            if (!_Asan_vector_should_annotate) {
                return;
            }

            const void* const _First    = _STD _Unfancy(_First_);
            const void* const _End      = _STD _Unfancy(_End_);
            const void* const _Old_last = _STD _Unfancy(_Old_last_);
            const void* const _New_last = _STD _Unfancy(_New_last_);
            if constexpr ((_Container_allocation_minimum_asan_alignment&lt;vector&gt;) &gt;= _Asan_granularity) {
                // old state:
                //   [_First, _Old_last) valid
                //   [_Old_last, _End) poison
                // new state:
                //   [_First, _New_last) valid
                //   [_New_last, asan_aligned_after(_End)) poison
                _CSTD __sanitizer_annotate_contiguous_container(
                    _First, _STD _Get_asan_aligned_after(_End), _Old_last, _New_last);
            } else {
                const auto _Aligned = _STD _Get_asan_aligned_first_end(_First, _End);
                if (_Aligned._First == _Aligned._End) {
                    // The buffer does not end at least one shadow memory section; nothing to do.
                    return;
                }

                const void* const _Old_fixed = _Aligned._Clamp_to_end(_Old_last);
                const void* const _New_fixed = _Aligned._Clamp_to_end(_New_last);

                // old state:
                //   [_Aligned._First, _Old_fixed) valid
                //   [_Old_fixed, _Aligned._End) poison
                //   [_Aligned._End, _End) valid
                // new state:
                //   [_Aligned._First, _New_fixed) valid
                //   [_New_fixed, _Aligned._End) poison
                //   [_Aligned._End, _End) valid
                _CSTD __sanitizer_annotate_contiguous_container(_Aligned._First, _Aligned._End, _Old_fixed, _New_fixed);
            }
        }
    }

    class _NODISCARD _Asan_extend_guard {
    public:
        _Asan_extend_guard(const _Asan_extend_guard&amp;)            = delete;
        _Asan_extend_guard&amp; operator=(const _Asan_extend_guard&amp;) = delete;

        constexpr explicit _Asan_extend_guard(vector* _Myvec_, size_type _Target_size_) noexcept
            : _Myvec(_Myvec_), _Target_size(_Target_size_) {
            _STL_INTERNAL_CHECK(_Myvec != nullptr);
            auto&amp; _My_data = _Myvec-&gt;_Mypair._Myval2;
            _Apply_annotation(_My_data._Myfirst, _My_data._Myend, _My_data._Mylast, _My_data._Myfirst + _Target_size);
        }

        _CONSTEXPR20 ~_Asan_extend_guard() {
            if (!_Myvec) { // Operation succeeded, no modification to the shadow memory required.
                return;
            }

            // Shrinks the shadow memory to the current size of the vector.
            auto&amp; _My_data = _Myvec-&gt;_Mypair._Myval2;
            _Apply_annotation(_My_data._Myfirst, _My_data._Myend, _My_data._Myfirst + _Target_size, _My_data._Mylast);
        }

        _CONSTEXPR20 void _Release() noexcept {
            _Myvec = nullptr;
        }

    private:
        vector* _Myvec;
        size_type _Target_size;
    };

    class _NODISCARD _Asan_create_guard {
    public:
        _Asan_create_guard(const _Asan_create_guard&amp;)            = delete;
        _Asan_create_guard&amp; operator=(const _Asan_create_guard&amp;) = delete;

        constexpr explicit _Asan_create_guard(const vector&amp; _Myvec_) noexcept : _Myvec(_Myvec_) {}

        _CONSTEXPR20 ~_Asan_create_guard() {
            _Myvec._Create_annotation();
        }

    private:
        const vector&amp; _Myvec;
    };

#define _ASAN_VECTOR_MODIFY(n)       _Modify_annotation((n))
#define _ASAN_VECTOR_REMOVE          _Remove_annotation()
#define _ASAN_VECTOR_CREATE          _Create_annotation()
#define _ASAN_VECTOR_CREATE_GUARD    _Asan_create_guard _Annotator(*this)
#define _ASAN_VECTOR_EXTEND_GUARD(n) _Asan_extend_guard _Annotator(this, (n))
#define _ASAN_VECTOR_RELEASE_GUARD   _Annotator._Release()
#else // ^^^ _INSERT_VECTOR_ANNOTATION / !_INSERT_VECTOR_ANNOTATION vvv
#define _ASAN_VECTOR_MODIFY(n)
#define _ASAN_VECTOR_REMOVE
#define _ASAN_VECTOR_CREATE
#define _ASAN_VECTOR_CREATE_GUARD
#define _ASAN_VECTOR_EXTEND_GUARD(n)
#define _ASAN_VECTOR_RELEASE_GUARD
#endif // ^^^ !_INSERT_VECTOR_ANNOTATION ^^^

    using _Scary_val = _Vector_val&lt;conditional_t&lt;_Is_simple_alloc_v&lt;_Alty&gt;, _Simple_types&lt;_Ty&gt;,
        _Vec_iter_types&lt;_Ty, size_type, difference_type, pointer, const_pointer&gt;&gt;&gt;;

    struct _NODISCARD _Reallocation_guard {
        _Alloc&amp; _Al;
        pointer _New_begin;
        size_type _New_capacity;
        pointer _Constructed_first;
        pointer _Constructed_last;

        _Reallocation_guard&amp; operator=(const _Reallocation_guard&amp;) = delete;
        _Reallocation_guard&amp; operator=(_Reallocation_guard&amp;&amp;)      = delete;

<span style = "background-color:#fdd">        _CONSTEXPR20 ~_Reallocation_guard() noexcept {
            if (_New_begin != nullptr) {
                _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);
                _Al.deallocate(_New_begin, _New_capacity);</span>
            }
<span style = "background-color:#fdd">        }</span>
    };

    struct _NODISCARD _Simple_reallocation_guard {
        _Alloc&amp; _Al;
        pointer _New_begin;
        size_type _New_capacity;

        _Simple_reallocation_guard&amp; operator=(const _Simple_reallocation_guard&amp;) = delete;
        _Simple_reallocation_guard&amp; operator=(_Simple_reallocation_guard&amp;&amp;)      = delete;

        _CONSTEXPR20 ~_Simple_reallocation_guard() noexcept {
            if (_New_begin != nullptr) {
                _Al.deallocate(_New_begin, _New_capacity);
            }
        }
    };

    struct _NODISCARD _Vaporization_guard { // vaporize the detached piece
        vector* _Target;
        pointer _Vaporized_first;
        pointer _Vaporized_last;
        pointer _Destroyed_first;

        _Vaporization_guard&amp; operator=(const _Vaporization_guard&amp;) = delete;
        _Vaporization_guard&amp; operator=(_Vaporization_guard&amp;&amp;)      = delete;

        ~_Vaporization_guard() noexcept {
            if (_Target != nullptr) {
                auto&amp; _Al     = _Target-&gt;_Getal();
                auto&amp; _Mylast = _Target-&gt;_Mypair._Myval2._Mylast;

                _Target-&gt;_Orphan_range(_Vaporized_first, _Vaporized_last);
                _STD _Destroy_range(_Destroyed_first, _Mylast, _Al);
                _Mylast = _Vaporized_first;
            }
        }
    };

public:
    using iterator               = _Vector_iterator&lt;_Scary_val&gt;;
    using const_iterator         = _Vector_const_iterator&lt;_Scary_val&gt;;
    using reverse_iterator       = _STD reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = _STD reverse_iterator&lt;const_iterator&gt;;

<span style = "background-color:#fdd">    _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v&lt;_Alty&gt;) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
    }</span>

    _CONSTEXPR20 explicit vector(const _Alloc&amp; _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
    }

    _CONSTEXPR20 explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc&amp; _Al = _Alloc())
<span style = "background-color:#fdd">        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Count);
    }</span>

#if _HAS_CXX17
    template &lt;class _Alloc2 = _Alloc, enable_if_t&lt;_Is_allocator&lt;_Alloc2&gt;::value, int&gt; = 0&gt;
#endif // _HAS_CXX17
    _CONSTEXPR20 vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty&amp; _Val, const _Alloc&amp; _Al = _Alloc())
<span style = "background-color:#fdd">        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Count, _Val);
    }</span>

    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20 vector(_Iter _First, _Iter _Last, const _Alloc&amp; _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _STD _Adl_verify_range(_First, _Last);
        auto _UFirst = _STD _Get_unwrapped(_First);
        auto _ULast  = _STD _Get_unwrapped(_Last);
        if constexpr (_Is_cpp17_fwd_iter_v&lt;_Iter&gt;) {
            const auto _Length = static_cast&lt;size_t&gt;(_STD distance(_UFirst, _ULast));
            const auto _Count  = _STD _Convert_size&lt;size_type&gt;(_Length);
            _Construct_n(_Count, _STD move(_UFirst), _STD move(_ULast));
#if _HAS_CXX20
        } else if constexpr (forward_iterator&lt;_Iter&gt;) {
            const auto _Length = _STD _To_unsigned_like(_RANGES distance(_UFirst, _ULast));
            const auto _Count  = _STD _Convert_size&lt;size_type&gt;(_Length);
            _Construct_n(_Count, _STD move(_UFirst), _STD move(_ULast));
#endif // _HAS_CXX20
        } else {
            auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
            _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_guard&lt;vector&gt; _Guard{this};

            _Append_uncounted_range(_STD move(_UFirst), _STD move(_ULast));

            _Guard._Target = nullptr;
            _Proxy._Release();
        }
    }

    _CONSTEXPR20 vector(initializer_list&lt;_Ty&gt; _Ilist, const _Alloc&amp; _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Convert_size&lt;size_type&gt;(_Ilist.size()), _Ilist.begin(), _Ilist.end());
    }

#if _HAS_CXX23
    template &lt;_Container_compatible_range&lt;_Ty&gt; _Rng&gt;
    constexpr vector(from_range_t, _Rng&amp;&amp; _Range, const _Alloc&amp; _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        if constexpr (_RANGES sized_range&lt;_Rng&gt; || _RANGES forward_range&lt;_Rng&gt;) {
            const auto _Length = _To_unsigned_like(_RANGES distance(_Range));
            const auto _Count  = _Convert_size&lt;size_type&gt;(_Length);
            _Construct_n(_Count, _RANGES _Ubegin(_Range), _RANGES _Uend(_Range));
        } else {
            auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
            _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_guard&lt;vector&gt; _Guard{this};

            _Append_uncounted_range(_RANGES _Ubegin(_Range), _RANGES _Uend(_Range));

            _Guard._Target = nullptr;
            _Proxy._Release();
        }
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 vector(const vector&amp; _Right)
<span style = "background-color:#fdd">        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        const auto&amp; _Right_data = _Right._Mypair._Myval2;
        const auto _Count       = static_cast&lt;size_type&gt;(_Right_data._Mylast - _Right_data._Myfirst);
        _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
    }</span>

    _CONSTEXPR20 vector(const vector&amp; _Right, const _Identity_t&lt;_Alloc&gt;&amp; _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        const auto&amp; _Right_data = _Right._Mypair._Myval2;
        const auto _Count       = static_cast&lt;size_type&gt;(_Right_data._Mylast - _Right_data._Myfirst);
        _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
    }

    _CONSTEXPR20 vector(vector&amp;&amp; _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),
              _STD exchange(_Right._Mypair._Myval2._Myfirst, nullptr),
              _STD exchange(_Right._Mypair._Myval2._Mylast, nullptr),
              _STD exchange(_Right._Mypair._Myval2._Myend, nullptr)) {
        _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    _CONSTEXPR20 vector(vector&amp;&amp; _Right, const _Identity_t&lt;_Alloc&gt;&amp; _Al_)
        noexcept(_Alty_traits::is_always_equal::value) // strengthened
        : _Mypair(_One_then_variadic_args_t{}, _Al_) {
        _Alty&amp; _Al        = _Getal();
        auto&amp;&amp; _Alproxy   = _GET_PROXY_ALLOCATOR(_Alty, _Al);
        auto&amp; _My_data    = _Mypair._Myval2;
        auto&amp; _Right_data = _Right._Mypair._Myval2;
        _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _My_data);

        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Al != _Right._Getal()) {
                const auto _Count = static_cast&lt;size_type&gt;(_Right_data._Mylast - _Right_data._Myfirst);
                if (_Count != 0) {
                    _Buy_raw(_Count);
                    _Tidy_guard&lt;vector&gt; _Guard{this};
                    _My_data._Mylast =
                        _Uninitialized_move(_Right_data._Myfirst, _Right_data._Mylast, _My_data._Myfirst, _Al);

                    _ASAN_VECTOR_CREATE;
                    _Guard._Target = nullptr;
                }
                _Proxy._Release();
                return;
            }
        }

        _My_data._Take_contents(_Right_data);
        _Proxy._Release();
    }

    _CONSTEXPR20 vector&amp; operator=(vector&amp;&amp; _Right)
        noexcept(_Choose_pocma_v&lt;_Alty&gt; != _Pocma_values::_No_propagate_allocators) {
        if (this == _STD addressof(_Right)) {
            return *this;
        }

        _Alty&amp; _Al                = _Getal();
        _Alty&amp; _Right_al          = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v&lt;_Alty&gt;;
        if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            if (_Al != _Right_al) {
                _Move_assign_unequal_alloc(_Right);
                return *this;
            }
        }

        _Tidy();
#if _ITERATOR_DEBUG_LEVEL != 0
        if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
            if (_Al != _Right_al) {
                // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
                _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
            }
        }
#endif // _ITERATOR_DEBUG_LEVEL != 0

        _Pocma(_Al, _Right_al);
        _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
        return *this;
    }

<span style = "background-color:#fdd">    _CONSTEXPR20 ~vector() noexcept {
        _Tidy();</span>
#if _ITERATOR_DEBUG_LEVEL != 0
<span style = "background-color:#fdd">        auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));</span>
#endif // _ITERATOR_DEBUG_LEVEL != 0
<span style = "background-color:#fdd">    }</span>

private:
    template &lt;class... _Valty&gt;
<span style = "background-color:#fdd">    _CONSTEXPR20 _Ty&amp; _Emplace_one_at_back(_Valty&amp;&amp;... _Val) {</span>
        // insert by perfectly forwarding into element at end, provide strong guarantee
<span style = "background-color:#fdd">        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;</span>

<span style = "background-color:#fdd">        if (_Mylast != _My_data._Myend) {
            return _Emplace_back_with_unused_capacity(_STD forward&lt;_Valty&gt;(_Val)...);</span>
        }

<span style = "background-color:#fdd">        return *_Emplace_reallocate(_Mylast, _STD forward&lt;_Valty&gt;(_Val)...);
    }</span>

    template &lt;class... _Valty&gt;
<span style = "background-color:#fdd">    _CONSTEXPR20 _Ty&amp; _Emplace_back_with_unused_capacity(_Valty&amp;&amp;... _Val) {</span>
        // insert by perfectly forwarding into element at end, provide strong guarantee
<span style = "background-color:#fdd">        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;</span>
        _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
        if constexpr (conjunction_v&lt;is_nothrow_constructible&lt;_Ty, _Valty...&gt;,
                          _Uses_default_construct&lt;_Alloc, _Ty*, _Valty...&gt;&gt;) {
            _ASAN_VECTOR_MODIFY(1);
<span style = "background-color:#fdd">            _STD _Construct_in_place(*_Mylast, _STD forward&lt;_Valty&gt;(_Val)...);</span>
        } else {
            _ASAN_VECTOR_EXTEND_GUARD(static_cast&lt;size_type&gt;(_Mylast - _My_data._Myfirst) + 1);
            _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward&lt;_Valty&gt;(_Val)...);
            _ASAN_VECTOR_RELEASE_GUARD;
        }

<span style = "background-color:#fdd">        _Orphan_range(_Mylast, _Mylast);
        _Ty&amp; _Result = *_Mylast;
        ++_Mylast;</span>

<span style = "background-color:#fdd">        return _Result;
    }</span>

    template &lt;class... _Valty&gt;
<span style = "background-color:#fdd">    _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&amp;&amp;... _Val) {</span>
        // reallocate and insert by perfectly forwarding _Val at _Whereptr
<span style = "background-color:#fdd">        _Alty&amp; _Al        = _Getal();
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;</span>

        _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity

<span style = "background-color:#fdd">        const auto _Whereoff = static_cast&lt;size_type&gt;(_Whereptr - _Myfirst);
        const auto _Oldsize  = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);</span>

<span style = "background-color:#fdd">        if (_Oldsize == max_size()) {
            _Xlength();</span>
        }

<span style = "background-color:#fdd">        const size_type _Newsize = _Oldsize + 1;
        size_type _Newcapacity   = _Calculate_growth(_Newsize);</span>

<span style = "background-color:#fdd">        const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);
        const pointer _Constructed_last = _Newvec + _Whereoff + 1;</span>

<span style = "background-color:#fdd">        _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};
        auto&amp; _Constructed_first = _Guard._Constructed_first;</span>

<span style = "background-color:#fdd">        _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward&lt;_Valty&gt;(_Val)...);
        _Constructed_first = _Newvec + _Whereoff;</span>

<span style = "background-color:#fdd">        if (_Whereptr == _Mylast) { // at back, provide strong guarantee</span>
            if constexpr (is_nothrow_move_constructible_v&lt;_Ty&gt; || !is_copy_constructible_v&lt;_Ty&gt;) {
<span style = "background-color:#fdd">                _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);</span>
            } else {
                _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
            }
<span style = "background-color:#fdd">        } else { // provide basic guarantee
            _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);
            _Constructed_first = _Newvec;
            _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);</span>
        }

<span style = "background-color:#fdd">        _Guard._New_begin = nullptr;
        _Change_array(_Newvec, _Newsize, _Newcapacity);
        return _Newvec + _Whereoff;
    }</span>

public:
    template &lt;class... _Valty&gt;
    _CONSTEXPR20 _CONTAINER_EMPLACE_RETURN emplace_back(_Valty&amp;&amp;... _Val) {
        // insert by perfectly forwarding into element at end, provide strong guarantee
        _Ty&amp; _Result = _Emplace_one_at_back(_STD forward&lt;_Valty&gt;(_Val)...);
#if _HAS_CXX17
        return _Result;
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
        (void) _Result;
#endif // ^^^ !_HAS_CXX17 ^^^
    }

    _CONSTEXPR20 void push_back(const _Ty&amp; _Val) { // insert element at end, provide strong guarantee
        _Emplace_one_at_back(_Val);
    }

<span style = "background-color:#fdd">    _CONSTEXPR20 void push_back(_Ty&amp;&amp; _Val) {</span>
        // insert by moving into element at end, provide strong guarantee
<span style = "background-color:#fdd">        _Emplace_one_at_back(_STD move(_Val));
    }</span>

private:
    template &lt;class _Iter, class _Sent&gt;
    _CONSTEXPR20 void _Append_uncounted_range(_Iter _First, const _Sent _Last) {
        // insert range [_First, _Last) at end

        // For one-at-back, provide strong guarantee.
        // Otherwise, provide basic guarantee (despite N4950 [vector.modifiers]/2).
        // Performance note: except for one-at-back, _Emplace_one_at_back()'s strong guarantee is unnecessary here.

        for (; _First != _Last; ++_First) {
            _Emplace_one_at_back(*_First);
        }
    }

#if _HAS_CXX23
    template &lt;class _Iter&gt;
    _CONSTEXPR20 void _Append_counted_range(_Iter _First, const size_type _Count) {
        // insert counted range _First + [0, _Count) at end
        auto&amp; _Al        = _Getal();
        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;

        const pointer _Oldfirst     = _My_data._Myfirst;
        const pointer _Oldlast      = _Mylast;
        const auto _Unused_capacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Oldlast);

        if (_Count == 0) { // nothing to do, avoid invalidating iterators
        } else if (_Count &gt; _Unused_capacity) { // reallocate
            const auto _Oldsize = static_cast&lt;size_type&gt;(_Oldlast - _Oldfirst);

            if (_Count &gt; max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize = _Oldsize + _Count;
            size_type _Newcapacity   = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);
            const pointer _Constructed_last = _Newvec + _Oldsize + _Count;

            _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};
            auto&amp; _Constructed_first = _Guard._Constructed_first;

            _Uninitialized_copy_n(_STD move(_First), _Count, _Newvec + _Oldsize, _Al);
            _Constructed_first = _Newvec + _Oldsize;

            if (_Count == 1) { // one at back, provide strong guarantee
                if constexpr (is_nothrow_move_constructible_v&lt;_Ty&gt; || !is_copy_constructible_v&lt;_Ty&gt;) {
                    _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
                } else {
                    _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
                }
            } else { // provide basic guarantee
                _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
            }

            _Guard._New_begin = nullptr;
            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else { // Provide the strong guarantee.
                 // Performance note: except for one-at-back, the strong guarantee is unnecessary here.

            _ASAN_VECTOR_EXTEND_GUARD(static_cast&lt;size_type&gt;(_Oldlast - _Oldfirst) + _Count);
            _Mylast = _Uninitialized_copy_n(_STD move(_First), _Count, _Oldlast, _Al);
            _ASAN_VECTOR_RELEASE_GUARD;

            _Orphan_range(_Oldlast, _Oldlast);
        }
    }
#endif // _HAS_CXX23

public:
#if _HAS_CXX23
    template &lt;_Container_compatible_range&lt;_Ty&gt; _Rng&gt;
    constexpr void append_range(_Rng&amp;&amp; _Range) {
        if constexpr (_RANGES forward_range&lt;_Rng&gt; || _RANGES sized_range&lt;_Rng&gt;) {
            const auto _Length = _To_unsigned_like(_RANGES distance(_Range));
            const auto _Count  = _Convert_size&lt;size_type&gt;(_Length);
            _Append_counted_range(_RANGES _Ubegin(_Range), _Count);
        } else {
            _Append_uncounted_range(_RANGES _Ubegin(_Range), _RANGES _Uend(_Range));
        }
    }
#endif // _HAS_CXX23

    template &lt;class... _Valty&gt;
    _CONSTEXPR20 iterator emplace(const_iterator _Where, _Valty&amp;&amp;... _Val) {
        // insert by perfectly forwarding _Val at _Where
        const pointer _Whereptr = _Where._Ptr;
        auto&amp; _My_data          = _Mypair._Myval2;
        const pointer _Oldlast  = _My_data._Mylast;
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_My_data) &amp;&amp; _Whereptr &gt;= _My_data._Myfirst &amp;&amp; _Oldlast &gt;= _Whereptr,
            "vector emplace iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        if (_Oldlast != _My_data._Myend) {
            if (_Whereptr == _Oldlast) { // at back, provide strong guarantee
                _Emplace_back_with_unused_capacity(_STD forward&lt;_Valty&gt;(_Val)...);
            } else {
                auto&amp; _Al = _Getal();
                _Alloc_temporary2&lt;_Alty&gt; _Obj(_Al, _STD forward&lt;_Valty&gt;(_Val)...); // handle aliasing
                // after constructing _Obj, provide basic guarantee
                _Orphan_range(_Whereptr, _Oldlast);
                _ASAN_VECTOR_EXTEND_GUARD(static_cast&lt;size_type&gt;(_Oldlast - _My_data._Myfirst) + 1);
                _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));
                _ASAN_VECTOR_RELEASE_GUARD;
                ++_My_data._Mylast;
                _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
                *_Whereptr = _STD move(_Obj._Get_value());
            }

            return _Make_iterator(_Whereptr);
        }

        return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward&lt;_Valty&gt;(_Val)...));
    }

    _CONSTEXPR20 iterator insert(const_iterator _Where, const _Ty&amp; _Val) { // insert _Val at _Where
        return emplace(_Where, _Val);
    }

    _CONSTEXPR20 iterator insert(const_iterator _Where, _Ty&amp;&amp; _Val) { // insert by moving _Val at _Where
        return emplace(_Where, _STD move(_Val));
    }

    _CONSTEXPR20 iterator insert(const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Ty&amp; _Val) {
        // insert _Count * _Val at _Where
        const pointer _Whereptr = _Where._Ptr;

        auto&amp; _Al        = _Getal();
        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;

        const pointer _Oldfirst = _My_data._Myfirst;
        const pointer _Oldlast  = _Mylast;
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Where._Getcont() == _STD addressof(_My_data) &amp;&amp; _Whereptr &gt;= _Oldfirst &amp;&amp; _Oldlast &gt;= _Whereptr,
            "vector insert iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        const auto _Whereoff        = static_cast&lt;size_type&gt;(_Whereptr - _Oldfirst);
        const auto _Unused_capacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Oldlast);
        const bool _One_at_back     = _Count == 1 &amp;&amp; _Whereptr == _Oldlast;
        if (_Count == 0) { // nothing to do, avoid invalidating iterators
        } else if (_Count &gt; _Unused_capacity) { // reallocate
            const auto _Oldsize = static_cast&lt;size_type&gt;(_Oldlast - _Oldfirst);

            if (_Count &gt; max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize = _Oldsize + _Count;
            size_type _Newcapacity   = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;

            _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};
            auto&amp; _Constructed_first = _Guard._Constructed_first;

            _Uninitialized_fill_n(_Newvec + _Whereoff, _Count, _Val, _Al);
            _Constructed_first = _Newvec + _Whereoff;

            if (_One_at_back) { // provide strong guarantee
                if constexpr (is_nothrow_move_constructible_v&lt;_Ty&gt; || !is_copy_constructible_v&lt;_Ty&gt;) {
                    _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
                } else {
                    _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
                }
            } else { // provide basic guarantee
                _Uninitialized_move(_Oldfirst, _Whereptr, _Newvec, _Al);
                _Constructed_first = _Newvec;
                _Uninitialized_move(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count, _Al);
            }

            _Guard._New_begin = nullptr;
            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else if (_One_at_back) { // provide strong guarantee
            _Emplace_back_with_unused_capacity(_Val);
        } else { // provide basic guarantee
            const _Alloc_temporary2&lt;_Alty&gt; _Tmp_storage(_Al, _Val); // handle aliasing
            const auto&amp; _Tmp              = _Tmp_storage._Get_value();
            const auto _Affected_elements = static_cast&lt;size_type&gt;(_Oldlast - _Whereptr);
            _Orphan_range(_Whereptr, _Oldlast);

            _ASAN_VECTOR_EXTEND_GUARD(static_cast&lt;size_type&gt;(_Oldlast - _My_data._Myfirst) + _Count);
            if (_Count &gt; _Affected_elements) { // new stuff spills off end
                _Mylast = _Uninitialized_fill_n(_Oldlast, _Count - _Affected_elements, _Tmp, _Al);
                _Mylast = _Uninitialized_move(_Whereptr, _Oldlast, _Mylast, _Al);
                _STD fill(_Whereptr, _Oldlast, _Tmp);
            } else { // new stuff can all be assigned
                _Mylast = _Uninitialized_move(_Oldlast - _Count, _Oldlast, _Oldlast, _Al);
                _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                _STD fill_n(_Whereptr, _Count, _Tmp);
            }
            _ASAN_VECTOR_RELEASE_GUARD;
        }

        return _Make_iterator_offset(_Whereoff);
    }

private:
    template &lt;class _Iter, class _Sent&gt;
    _CONSTEXPR20 void _Insert_uncounted_range(const_iterator _Where, _Iter _First, _Sent _Last) {
        // insert range [_First, _Last) at _Where
        if (_First == _Last) {
            return; // nothing to do, avoid invalidating iterators
        }

        auto&amp; _My_data       = _Mypair._Myval2;
        pointer&amp; _Myfirst    = _My_data._Myfirst;
        pointer&amp; _Mylast     = _My_data._Mylast;
        const auto _Whereoff = static_cast&lt;size_type&gt;(_Where._Ptr - _Myfirst);
        const auto _Oldsize  = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);

        _Append_uncounted_range(_STD move(_First), _STD move(_Last));

        _Orphan_range(_Myfirst + _Whereoff, _Myfirst + _Oldsize);

        _STD rotate(_Myfirst + _Whereoff, _Myfirst + _Oldsize, _Mylast);
    }

    template &lt;class _Iter&gt;
    _CONSTEXPR20 void _Insert_counted_range(const_iterator _Where, _Iter _First, const size_type _Count) {
        // insert counted range _First + [0, _Count) at _Where
        const pointer _Whereptr = _Where._Ptr;

        auto&amp; _Al        = _Getal();
        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;

        const pointer _Oldfirst     = _My_data._Myfirst;
        const pointer _Oldlast      = _Mylast;
        const auto _Unused_capacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Oldlast);

        if (_Count == 0) { // nothing to do, avoid invalidating iterators
        } else if (_Count &gt; _Unused_capacity) { // reallocate
            const auto _Oldsize = static_cast&lt;size_type&gt;(_Oldlast - _Oldfirst);

            if (_Count &gt; max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize = _Oldsize + _Count;
            size_type _Newcapacity   = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _STD _Allocate_at_least_helper(_Al, _Newcapacity);
            const auto _Whereoff            = static_cast&lt;size_type&gt;(_Whereptr - _Oldfirst);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;

            _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};
            auto&amp; _Constructed_first = _Guard._Constructed_first;

            _STD _Uninitialized_copy_n(_STD move(_First), _Count, _Newvec + _Whereoff, _Al);
            _Constructed_first = _Newvec + _Whereoff;

            if (_Count == 1 &amp;&amp; _Whereptr == _Oldlast) { // one at back, provide strong guarantee
                if constexpr (is_nothrow_move_constructible_v&lt;_Ty&gt; || !is_copy_constructible_v&lt;_Ty&gt;) {
                    _STD _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
                } else {
                    _STD _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
                }
            } else { // provide basic guarantee
                _STD _Uninitialized_move(_Oldfirst, _Whereptr, _Newvec, _Al);
                _Constructed_first = _Newvec;
                _STD _Uninitialized_move(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count, _Al);
            }

            _Guard._New_begin = nullptr;
            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else { // Attempt to provide the strong guarantee for EmplaceConstructible failure.
                 // If we encounter copy/move construction/assignment failure, provide the basic guarantee.
                 // (For one-at-back, this provides the strong guarantee.)

            const auto _Affected_elements = static_cast&lt;size_type&gt;(_Oldlast - _Whereptr);

            _ASAN_VECTOR_EXTEND_GUARD(static_cast&lt;size_type&gt;(_Oldlast - _Oldfirst) + _Count);
            if (_Count &lt; _Affected_elements) { // some affected elements must be assigned
                _Mylast = _STD _Uninitialized_move(_Oldlast - _Count, _Oldlast, _Oldlast, _Al);
                _STD _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                _STD _Destroy_range(_Whereptr, _Whereptr + _Count, _Al);

                _TRY_BEGIN
                _STD _Uninitialized_copy_n(_STD move(_First), _Count, _Whereptr, _Al);
                _CATCH_ALL
                // glue the broken pieces back together

                _Vaporization_guard _Guard{this, _Whereptr, _Oldlast, _Whereptr + _Count};
                _STD _Uninitialized_move(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr, _Al);
                _Guard._Target = nullptr;

                _STD _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);
                _STD _Destroy_range(_Oldlast, _Mylast, _Al);
                _Mylast = _Oldlast;
                _RERAISE;
                _CATCH_END
            } else { // affected elements don't overlap before/after
                const pointer _Relocated = _Whereptr + _Count;
                _Mylast                  = _STD _Uninitialized_move(_Whereptr, _Oldlast, _Relocated, _Al);
                _STD _Destroy_range(_Whereptr, _Oldlast, _Al);

                _TRY_BEGIN
                _STD _Uninitialized_copy_n(_STD move(_First), _Count, _Whereptr, _Al);
                _CATCH_ALL
                // glue the broken pieces back together

                _Vaporization_guard _Guard{this, _Whereptr, _Oldlast, _Relocated};
                _STD _Uninitialized_move(_Relocated, _Mylast, _Whereptr, _Al);
                _Guard._Target = nullptr;

                _STD _Destroy_range(_Relocated, _Mylast, _Al);
                _Mylast = _Oldlast;
                _RERAISE;
                _CATCH_END
            }

            _Orphan_range(_Whereptr, _Oldlast);
            _ASAN_VECTOR_RELEASE_GUARD;
        }
    }

public:
    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20 iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        const pointer _Whereptr = _Where._Ptr;
        auto&amp; _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_My_data) &amp;&amp; _Whereptr &gt;= _Oldfirst &amp;&amp; _My_data._Mylast &gt;= _Whereptr,
            "vector insert iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _STD _Adl_verify_range(_First, _Last);
        auto _UFirst         = _STD _Get_unwrapped(_First);
        auto _ULast          = _STD _Get_unwrapped(_Last);
        const auto _Whereoff = static_cast&lt;size_type&gt;(_Whereptr - _Oldfirst);
        if constexpr (_Is_cpp17_fwd_iter_v&lt;_Iter&gt;) {
            const auto _Length = static_cast&lt;size_t&gt;(_STD distance(_UFirst, _ULast));
            const auto _Count  = _STD _Convert_size&lt;size_type&gt;(_Length);
            _Insert_counted_range(_Where, _UFirst, _Count);
#if _HAS_CXX20
        } else if constexpr (forward_iterator&lt;_Iter&gt;) {
            const auto _Length = _STD _To_unsigned_like(_RANGES distance(_UFirst, _ULast));
            const auto _Count  = _Convert_size&lt;size_type&gt;(_Length);
            _Insert_counted_range(_Where, _UFirst, _Count);
#endif // _HAS_CXX20
        } else {
            _Insert_uncounted_range(_Where, _UFirst, _ULast);
        }
        return _Make_iterator_offset(_Whereoff);
    }

#if _HAS_CXX23
    template &lt;_Container_compatible_range&lt;_Ty&gt; _Rng&gt;
    constexpr iterator insert_range(const_iterator _Where, _Rng&amp;&amp; _Range) {
        const pointer _Whereptr = _Where._Ptr;
        auto&amp; _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_My_data) &amp;&amp; _Whereptr &gt;= _Oldfirst &amp;&amp; _My_data._Mylast &gt;= _Whereptr,
            "vector insert_range iterator out-of-range");
#endif // _ITERATOR_DEBUG_LEVEL == 2
        const auto _Whereoff = static_cast&lt;size_type&gt;(_Whereptr - _Oldfirst);

        if constexpr (_RANGES forward_range&lt;_Rng&gt; || _RANGES sized_range&lt;_Rng&gt;) {
            const auto _Length = _To_unsigned_like(_RANGES distance(_Range));
            const auto _Count  = _Convert_size&lt;size_type&gt;(_Length);
            _Insert_counted_range(_Where, _RANGES _Ubegin(_Range), _Count);
        } else {
            _Insert_uncounted_range(_Where, _RANGES _Ubegin(_Range), _RANGES _Uend(_Range));
        }
        return _Make_iterator_offset(_Whereoff);
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 iterator insert(const_iterator _Where, initializer_list&lt;_Ty&gt; _Ilist) {
        const pointer _Whereptr = _Where._Ptr;
        auto&amp; _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_My_data) &amp;&amp; _Whereptr &gt;= _Oldfirst &amp;&amp; _My_data._Mylast &gt;= _Whereptr,
            "vector insert iterator out-of-range");
#endif // _ITERATOR_DEBUG_LEVEL == 2
        const auto _Whereoff = static_cast&lt;size_type&gt;(_Whereptr - _Oldfirst);

        const auto _Count = _Convert_size&lt;size_type&gt;(_Ilist.size());
        _Insert_counted_range(_Where, _Ilist.begin(), _Count);
        return _Make_iterator_offset(_Whereoff);
    }

    _CONSTEXPR20 void assign(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty&amp; _Val) {
        // assign _Newsize * _Val
        auto&amp; _Al         = _Getal();
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

#if _ITERATOR_DEBUG_LEVEL == 2
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            const auto _Valptr = _STD addressof(_Val);
            _STL_VERIFY(!(_Unfancy(_Myfirst) &lt;= _Valptr &amp;&amp; _Valptr &lt; _Unfancy(_Mylast)),
                "assignment value cannot be a reference into the container");
        }
#endif // _ITERATOR_DEBUG_LEVEL == 2

        constexpr bool _Nothrow_construct =
            conjunction_v&lt;is_nothrow_copy_constructible&lt;_Ty&gt;, _Uses_default_construct&lt;_Alloc, _Ty*, const _Ty&amp;&gt;&gt;;

        _My_data._Orphan_all();
        const auto _Oldcapacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Myfirst);
        if (_Newsize &gt; _Oldcapacity) { // reallocate
            _Clear_and_reserve_geometric(_Newsize);
            if constexpr (_Nothrow_construct) {
                _Mylast = _Uninitialized_fill_n(_Myfirst, _Newsize, _Val, _Al);
                _ASAN_VECTOR_CREATE;
            } else {
                _ASAN_VECTOR_CREATE_GUARD;
                _Mylast = _Uninitialized_fill_n(_Myfirst, _Newsize, _Val, _Al);
            }

            return;
        }

        const auto _Oldsize = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);
        if (_Newsize &gt; _Oldsize) {
            _STD fill(_Myfirst, _Mylast, _Val);
            if constexpr (_Nothrow_construct) {
                _ASAN_VECTOR_MODIFY(static_cast&lt;difference_type&gt;(_Newsize - _Oldsize));
                _Mylast = _Uninitialized_fill_n(_Mylast, _Newsize - _Oldsize, _Val, _Al);
            } else {
                _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
                _Mylast = _Uninitialized_fill_n(_Mylast, _Newsize - _Oldsize, _Val, _Al);
                _ASAN_VECTOR_RELEASE_GUARD;
            }
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            _STD fill(_Myfirst, _Newlast, _Val);
            _Destroy_range(_Newlast, _Mylast, _Al);
            _ASAN_VECTOR_MODIFY(static_cast&lt;difference_type&gt;(_Newsize - _Oldsize));
            _Mylast = _Newlast;
        }
    }

private:
    template &lt;class _Iter, class _Sent&gt;
    _CONSTEXPR20 void _Assign_uncounted_range(_Iter _First, _Sent _Last) {
        // assign unknown number of elements from [_First, _Last)
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();

        pointer _Next = _Myfirst;
        for (; _First != _Last &amp;&amp; _Next != _Mylast; ++_First, (void) ++_Next) {
            *_Next = *_First;
        }

        // Code size optimization: we've exhausted only the source, only the dest, or both.
        // If we've exhausted only the source: we Trim, then Append does nothing.
        // If we've exhausted only the dest: Trim does nothing, then we Append.
        // If we've exhausted both: Trim does nothing, then Append does nothing.

        // Trim.
        _Destroy_range(_Next, _Mylast, _Getal());
        _ASAN_VECTOR_MODIFY(static_cast&lt;difference_type&gt;(_Next - _Mylast)); // negative when destroying elements
        _Mylast = _Next;

        _Append_uncounted_range(_STD move(_First), _STD move(_Last));
    }

    template &lt;class _Iter&gt;
    _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {
        // assign elements from counted range _First + [0, _Newsize)
        auto&amp; _Al         = _Getal();
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;

        constexpr bool _Nothrow_construct = conjunction_v&lt;is_nothrow_constructible&lt;_Ty, _Iter_ref_t&lt;_Iter&gt;&gt;,
            _Uses_default_construct&lt;_Alloc, _Ty*, _Iter_ref_t&lt;_Iter&gt;&gt;&gt;;

        _My_data._Orphan_all();
        const auto _Oldcapacity = static_cast&lt;size_type&gt;(_Myend - _Myfirst);
        if (_Newsize &gt; _Oldcapacity) {
            _Clear_and_reserve_geometric(_Newsize);
            if constexpr (_Nothrow_construct) {
                _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
                _ASAN_VECTOR_CREATE;
            } else {
                _ASAN_VECTOR_CREATE_GUARD;
                _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
            }
            return;
        }

        const auto _Oldsize = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);
        if (_Newsize &gt; _Oldsize) {
            bool _Copied = false;
            if constexpr (_Iter_copy_cat&lt;_Iter, pointer&gt;::_Bitcopy_assignable) {
#if _HAS_CXX20
                if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
                {
                    _Copy_memmove_n(_First, static_cast&lt;size_t&gt;(_Oldsize), _Myfirst);
                    _First += _Oldsize;
                    _Copied = true;
                }
            }

            if (!_Copied) {
                for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {
                    *_Mid = *_First;
                }
            }

            if constexpr (_Nothrow_construct) {
                _ASAN_VECTOR_MODIFY(static_cast&lt;difference_type&gt;(_Newsize - _Oldsize));
                _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
            } else {
                _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
                _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
                _ASAN_VECTOR_RELEASE_GUARD;
            }
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            _STD _Copy_n_unchecked4(_STD move(_First), _Newsize, _Myfirst);
            _STD _Destroy_range(_Newlast, _Mylast, _Al);
            _ASAN_VECTOR_MODIFY(static_cast&lt;difference_type&gt;(_Newsize - _Oldsize));
            _Mylast = _Newlast;
        }
    }

public:
    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20 void assign(_Iter _First, _Iter _Last) {
        _STD _Adl_verify_range(_First, _Last);
        auto _UFirst = _STD _Get_unwrapped(_First);
        auto _ULast  = _STD _Get_unwrapped(_Last);
        if constexpr (_Is_cpp17_fwd_iter_v&lt;_Iter&gt;) {
            const auto _Length = static_cast&lt;size_t&gt;(_STD distance(_UFirst, _ULast));
            const auto _Count  = _STD _Convert_size&lt;size_type&gt;(_Length);
            _Assign_counted_range(_UFirst, _Count);
#if _HAS_CXX20
        } else if constexpr (forward_iterator&lt;_Iter&gt;) {
            const auto _Length = _STD _To_unsigned_like(_RANGES distance(_UFirst, _ULast));
            const auto _Count  = _STD _Convert_size&lt;size_type&gt;(_Length);
            _Assign_counted_range(_UFirst, _Count);
#endif // _HAS_CXX20
        } else {
            _Assign_uncounted_range(_UFirst, _ULast);
        }
    }

#if _HAS_CXX23
    template &lt;_Container_compatible_range&lt;_Ty&gt; _Rng&gt;
    constexpr void assign_range(_Rng&amp;&amp; _Range) {
        static_assert(assignable_from&lt;_Ty&amp;, _RANGES range_reference_t&lt;_Rng&gt;&gt;,
            "Elements must be assignable from the range's reference type (N4993 [sequence.reqmts]/60).");
        if constexpr (_RANGES sized_range&lt;_Rng&gt; || _RANGES forward_range&lt;_Rng&gt;) {
            const auto _Length = _To_unsigned_like(_RANGES distance(_Range));
            const auto _Count  = _Convert_size&lt;size_type&gt;(_Length);
            _Assign_counted_range(_RANGES _Ubegin(_Range), _Count);
        } else {
            _Assign_uncounted_range(_RANGES _Ubegin(_Range), _RANGES _Uend(_Range));
        }
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 void assign(const initializer_list&lt;_Ty&gt; _Ilist) {
        const auto _Count = _Convert_size&lt;size_type&gt;(_Ilist.size());
        _Assign_counted_range(_Ilist.begin(), _Count);
    }

    _CONSTEXPR20 vector&amp; operator=(const vector&amp; _Right) {
        if (this == _STD addressof(_Right)) {
            return *this;
        }

        auto&amp; _Al       = _Getal();
        auto&amp; _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v&lt;_Alty&gt;) {
            if (_Al != _Right_al) {
                _Tidy();
                _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
            }
        }

        _Pocca(_Al, _Right_al);
        auto&amp; _Right_data = _Right._Mypair._Myval2;
        _Assign_counted_range(_Right_data._Myfirst, static_cast&lt;size_type&gt;(_Right_data._Mylast - _Right_data._Myfirst));

        return *this;
    }

    _CONSTEXPR20 vector&amp; operator=(initializer_list&lt;_Ty&gt; _Ilist) {
        const auto _Count = _Convert_size&lt;size_type&gt;(_Ilist.size());
        _Assign_counted_range(_Ilist.begin(), _Count);
        return *this;
    }

private:
    template &lt;class _Ty2&gt;
    _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2&amp; _Val) {
        if (_Newsize &gt; max_size()) {
            _Xlength();
        }

        auto&amp; _Al         = _Getal();
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

        const auto _Oldsize    = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);
        size_type _Newcapacity = _Calculate_growth(_Newsize);

        const pointer _Newvec         = _Allocate_at_least_helper(_Al, _Newcapacity);
        const pointer _Appended_first = _Newvec + _Oldsize;

        _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Appended_first, _Appended_first};
        auto&amp; _Appended_last = _Guard._Constructed_last;

        if constexpr (is_same_v&lt;_Ty2, _Ty&gt;) {
            _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
        } else {
            _STL_INTERNAL_STATIC_ASSERT(is_same_v&lt;_Ty2, _Value_init_tag&gt;);
            _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);
        }

        if constexpr (is_nothrow_move_constructible_v&lt;_Ty&gt; || !is_copy_constructible_v&lt;_Ty&gt;) {
            _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
        } else {
            _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
        }

        _Guard._New_begin = nullptr;
        _Change_array(_Newvec, _Newsize, _Newcapacity);
    }

    template &lt;class _Ty2&gt;
    _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2&amp; _Val) {
        // trim or append elements, provide strong guarantee
        auto&amp; _Al           = _Getal();
        auto&amp; _My_data      = _Mypair._Myval2;
        pointer&amp; _Myfirst   = _My_data._Myfirst;
        pointer&amp; _Mylast    = _My_data._Mylast;
        const auto _Oldsize = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);
        if (_Newsize &lt; _Oldsize) { // trim
            const pointer _Newlast = _Myfirst + _Newsize;
            _Orphan_range(_Newlast, _Mylast);
            _Destroy_range(_Newlast, _Mylast, _Al);
            _ASAN_VECTOR_MODIFY(static_cast&lt;difference_type&gt;(_Newsize - _Oldsize));
            _Mylast = _Newlast;
            return;
        }

        if (_Newsize &gt; _Oldsize) { // append
            const auto _Oldcapacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Myfirst);
            if (_Newsize &gt; _Oldcapacity) { // reallocate
                _Resize_reallocate(_Newsize, _Val);
                return;
            }

            _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
            const pointer _Oldlast = _Mylast;
            if constexpr (is_same_v&lt;_Ty2, _Ty&gt;) {
                _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
            } else {
                _STL_INTERNAL_STATIC_ASSERT(is_same_v&lt;_Ty2, _Value_init_tag&gt;);
                _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);
            }
            _ASAN_VECTOR_RELEASE_GUARD;
            _Orphan_range(_Oldlast, _Oldlast);
        }

        // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
    }

public:
    _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {
        // trim or append value-initialized elements, provide strong guarantee
        _Resize(_Newsize, _Value_init_tag{});
    }

    _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty&amp; _Val) {
        // trim or append copies of _Val, provide strong guarantee
        _Resize(_Newsize, _Val);
    }

private:
    enum class _Reallocation_policy { _At_least, _Exactly };

    template &lt;_Reallocation_policy _Policy&gt;
    _CONSTEXPR20 void _Reallocate(size_type&amp; _Newcapacity) {
        // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
        auto&amp; _Al         = _Getal();
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

        const auto _Size = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);

        pointer _Newvec;
        if constexpr (_Policy == _Reallocation_policy::_At_least) {
            _Newvec = _Allocate_at_least_helper(_Al, _Newcapacity);
        } else {
            _STL_INTERNAL_STATIC_ASSERT(_Policy == _Reallocation_policy::_Exactly);
            _Newvec = _Al.allocate(_Newcapacity);
        }

        _Simple_reallocation_guard _Guard{_Al, _Newvec, _Newcapacity};

        if constexpr (is_nothrow_move_constructible_v&lt;_Ty&gt; || !is_copy_constructible_v&lt;_Ty&gt;) {
            _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
        } else {
            _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
        }

        _Guard._New_begin = nullptr;
        _Change_array(_Newvec, _Size, _Newcapacity);
    }

#if _ITERATOR_DEBUG_LEVEL != 0 &amp;&amp; defined(_ENABLE_STL_INTERNAL_CHECK)
    void _Check_all_orphaned_locked() const noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        auto&amp; _My_data = _Mypair._Myval2;
        _STL_INTERNAL_CHECK(!_My_data._Myproxy-&gt;_Myfirstiter);
    }

    _CONSTEXPR20 void _Check_all_orphaned() const noexcept {
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            auto&amp; _My_data = _Mypair._Myval2;
            _STL_INTERNAL_CHECK(!_My_data._Myproxy-&gt;_Myfirstiter);
        } else
#endif // _HAS_CXX20
        {
            _Check_all_orphaned_locked();
        }
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0 &amp;&amp; defined(_ENABLE_STL_INTERNAL_CHECK)

    _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {
        auto&amp; _Al         = _Getal();
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;

#if _ITERATOR_DEBUG_LEVEL != 0 &amp;&amp; defined(_ENABLE_STL_INTERNAL_CHECK)
        _STL_INTERNAL_CHECK(_Newsize != 0);
        _Check_all_orphaned();
#endif // _ITERATOR_DEBUG_LEVEL != 0 &amp;&amp; defined(_ENABLE_STL_INTERNAL_CHECK)

        if (_Newsize &gt; max_size()) {
            _Xlength();
        }

        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        if (_Myfirst) { // destroy and deallocate old array
            _Destroy_range(_Myfirst, _Mylast, _Al);
            _ASAN_VECTOR_REMOVE;
            _Al.deallocate(_Myfirst, static_cast&lt;size_type&gt;(_Myend - _Myfirst));

            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;
        }

        _Buy_raw(_Newcapacity);
    }

public:
    _CONSTEXPR20 void reserve(_CRT_GUARDOVERFLOW size_type _Newcapacity) {
        // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
        if (_Newcapacity &gt; capacity()) { // something to do (reserve() never shrinks)
            if (_Newcapacity &gt; max_size()) {
                _Xlength();
            }

            _Reallocate&lt;_Reallocation_policy::_At_least&gt;(_Newcapacity);
        }
    }

    _CONSTEXPR20 void shrink_to_fit() { // reduce capacity to size, provide strong guarantee
        auto&amp; _My_data         = _Mypair._Myval2;
        const pointer _Oldlast = _My_data._Mylast;
        if (_Oldlast != _My_data._Myend) { // something to do
            const pointer _Oldfirst = _My_data._Myfirst;
            if (_Oldfirst == _Oldlast) {
                _Tidy();
            } else {
                size_type _Newcapacity = static_cast&lt;size_type&gt;(_Oldlast - _Oldfirst);
                _Reallocate&lt;_Reallocation_policy::_Exactly&gt;(_Newcapacity);
            }
        }
    }

<span style = "background-color:#fdd">    _CONSTEXPR20 void pop_back() noexcept /* strengthened */ {
        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;</span>

#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
<span style = "background-color:#fdd">        _STL_VERIFY(_My_data._Myfirst != _Mylast, "pop_back() called on empty vector");</span>
#endif

<span style = "background-color:#fdd">        _Orphan_range(_Mylast - 1, _Mylast);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));</span>
        _ASAN_VECTOR_MODIFY(-1);
<span style = "background-color:#fdd">        --_Mylast;
    }</span>

    _CONSTEXPR20 iterator erase(const_iterator _Where)
        noexcept(is_nothrow_move_assignable_v&lt;value_type&gt;) /* strengthened */ {
        const pointer _Whereptr = _Where._Ptr;
        auto&amp; _My_data          = _Mypair._Myval2;
        pointer&amp; _Mylast        = _My_data._Mylast;

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_My_data) &amp;&amp; _Whereptr &gt;= _My_data._Myfirst &amp;&amp; _Mylast &gt; _Whereptr,
            "vector erase iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Orphan_range(_Whereptr, _Mylast);
        _STD _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        _ASAN_VECTOR_MODIFY(-1);
        --_Mylast;
        return iterator(_Whereptr, _STD addressof(_My_data));
    }

    _CONSTEXPR20 iterator erase(const_iterator _First, const_iterator _Last)
        noexcept(is_nothrow_move_assignable_v&lt;value_type&gt;) /* strengthened */ {
        const pointer _Firstptr = _First._Ptr;
        const pointer _Lastptr  = _Last._Ptr;
        auto&amp; _My_data          = _Mypair._Myval2;
        pointer&amp; _Mylast        = _My_data._Mylast;

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) &amp;&amp; _Last._Getcont() == _STD addressof(_My_data)
                        &amp;&amp; _Firstptr &gt;= _My_data._Myfirst &amp;&amp; _Lastptr &gt;= _Firstptr &amp;&amp; _Mylast &gt;= _Lastptr,
            "vector erase iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        if (_Firstptr != _Lastptr) { // something to do, invalidate iterators
            _Orphan_range(_Firstptr, _Mylast);

            const pointer _Newlast = _STD _Move_unchecked(_Lastptr, _Mylast, _Firstptr);
            _Destroy_range(_Newlast, _Mylast, _Getal());
            _ASAN_VECTOR_MODIFY(static_cast&lt;difference_type&gt;(_Newlast - _Mylast)); // negative when destroying elements
            _Mylast = _Newlast;
        }

        return iterator(_Firstptr, _STD addressof(_My_data));
    }

    _CONSTEXPR20 void clear() noexcept { // erase all
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

        if (_Myfirst == _Mylast) { // already empty, nothing to do
            // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
            // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
            // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
            return;
        }

        _My_data._Orphan_all();
        _Destroy_range(_Myfirst, _Mylast, _Getal());
        _ASAN_VECTOR_MODIFY(static_cast&lt;difference_type&gt;(_Myfirst - _Mylast)); // negative when destroying elements
        _Mylast = _Myfirst;
    }

    _CONSTEXPR20 void swap(vector&amp; _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            _Mypair._Myval2._Swap_val(_Right._Mypair._Myval2);
        }
    }

    _NODISCARD _CONSTEXPR20 _Ty* data() noexcept {
        return _STD _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    _NODISCARD _CONSTEXPR20 const _Ty* data() const noexcept {
        return _STD _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 iterator begin() noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst, _STD addressof(_My_data));
    }</span>

    _NODISCARD _CONSTEXPR20 const_iterator begin() const noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));
    }

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 iterator end() noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return iterator(_My_data._Mylast, _STD addressof(_My_data));
    }</span>

    _NODISCARD _CONSTEXPR20 const_iterator end() const noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Mylast, _STD addressof(_My_data));
    }

    _NODISCARD _CONSTEXPR20 reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    _NODISCARD _CONSTEXPR20 reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    _NODISCARD _CONSTEXPR20 const_iterator cbegin() const noexcept {
        return begin();
    }

    _NODISCARD _CONSTEXPR20 const_iterator cend() const noexcept {
        return end();
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator crend() const noexcept {
        return rend();
    }

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 _Ty* _Unchecked_begin() noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }</span>

    _NODISCARD _CONSTEXPR20 const _Ty* _Unchecked_begin() const noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 _Ty* _Unchecked_end() noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Mylast);
    }</span>

    _NODISCARD _CONSTEXPR20 const _Ty* _Unchecked_end() const noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Mylast);
    }

    _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return _My_data._Myfirst == _My_data._Mylast;
    }

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 size_type size() const noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return static_cast&lt;size_type&gt;(_My_data._Mylast - _My_data._Myfirst);
    }</span>

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {
        return (_STD min)(static_cast&lt;size_type&gt;(_STD _Max_limit&lt;difference_type&gt;()), _Alty_traits::max_size(_Getal()));
    }</span>

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return static_cast&lt;size_type&gt;(_My_data._Myend - _My_data._Myfirst);
    }</span>

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 _Ty&amp; operator[](const size_type _Pos) noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;</span>
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
<span style = "background-color:#fdd">        _STL_VERIFY(</span>
            _Pos &lt; static_cast&lt;size_type&gt;(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
#endif

<span style = "background-color:#fdd">        return _My_data._Myfirst[_Pos];
    }</span>

    _NODISCARD _CONSTEXPR20 const _Ty&amp; operator[](const size_type _Pos) const noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(
            _Pos &lt; static_cast&lt;size_type&gt;(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
#endif

        return _My_data._Myfirst[_Pos];
    }

    _NODISCARD _CONSTEXPR20 _Ty&amp; at(const size_type _Pos) {
        auto&amp; _My_data = _Mypair._Myval2;
        if (static_cast&lt;size_type&gt;(_My_data._Mylast - _My_data._Myfirst) &lt;= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    _NODISCARD _CONSTEXPR20 const _Ty&amp; at(const size_type _Pos) const {
        auto&amp; _My_data = _Mypair._Myval2;
        if (static_cast&lt;size_type&gt;(_My_data._Mylast - _My_data._Myfirst) &lt;= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    _NODISCARD _CONSTEXPR20 _Ty&amp; front() noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "front() called on empty vector");
#endif

        return *_My_data._Myfirst;
    }

    _NODISCARD _CONSTEXPR20 const _Ty&amp; front() const noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "front() called on empty vector");
#endif

        return *_My_data._Myfirst;
    }

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 _Ty&amp; back() noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;</span>
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
<span style = "background-color:#fdd">        _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");</span>
#endif

<span style = "background-color:#fdd">        return _My_data._Mylast[-1];
    }</span>

    _NODISCARD _CONSTEXPR20 const _Ty&amp; back() const noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
#endif

        return _My_data._Mylast[-1];
    }

    _NODISCARD _CONSTEXPR20 allocator_type get_allocator() const noexcept {
        return static_cast&lt;allocator_type&gt;(_Getal());
    }

private:
<span style = "background-color:#fdd">    _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {</span>
        // given _Oldcapacity and _Newsize, calculate geometric growth
<span style = "background-color:#fdd">        const size_type _Oldcapacity = capacity();
        const auto _Max              = max_size();</span>

<span style = "background-color:#fdd">        if (_Oldcapacity &gt; _Max - _Oldcapacity / 2) {
            return _Max; // geometric growth would overflow</span>
        }

<span style = "background-color:#fdd">        const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;</span>

<span style = "background-color:#fdd">        if (_Geometric &lt; _Newsize) {
            return _Newsize; // geometric growth would be insufficient</span>
        }

<span style = "background-color:#fdd">        return _Geometric; // geometric growth is sufficient
    }</span>

<span style = "background-color:#fdd">    _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {</span>
        // allocate array with _Newcapacity elements
<span style = "background-color:#fdd">        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;</span>

        _STL_INTERNAL_CHECK(!_Myfirst &amp;&amp; !_Mylast &amp;&amp; !_Myend); // check that *this is tidy
        _STL_INTERNAL_CHECK(0 &lt; _Newcapacity &amp;&amp; _Newcapacity &lt;= max_size());

<span style = "background-color:#fdd">        const pointer _Newvec = _STD _Allocate_at_least_helper(_Getal(), _Newcapacity);
        _Myfirst              = _Newvec;
        _Mylast               = _Newvec;
        _Myend                = _Newvec + _Newcapacity;
    }</span>

<span style = "background-color:#fdd">    _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {</span>
        // allocate array with _Newcapacity elements
#ifdef _ENABLE_STL_INTERNAL_CHECK
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;
        _STL_INTERNAL_CHECK(!_Myfirst &amp;&amp; !_Mylast &amp;&amp; !_Myend); // check that *this is tidy
        _STL_INTERNAL_CHECK(0 &lt; _Newcapacity);
#endif // _ENABLE_STL_INTERNAL_CHECK

<span style = "background-color:#fdd">        if (_Newcapacity &gt; max_size()) {
            _Xlength();</span>
        }

<span style = "background-color:#fdd">        _Buy_raw(_Newcapacity);
    }</span>

    _CONSTEXPR20 void _Change_array(
<span style = "background-color:#fdd">        const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {</span>
        // orphan all iterators, discard old array, acquire new array
<span style = "background-color:#fdd">        auto&amp; _Al         = _Getal();
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;</span>

<span style = "background-color:#fdd">        _My_data._Orphan_all();</span>

<span style = "background-color:#fdd">        if (_Myfirst) { // destroy and deallocate old array
            _STD _Destroy_range(_Myfirst, _Mylast, _Al);</span>
            _ASAN_VECTOR_REMOVE;
<span style = "background-color:#fdd">            _Al.deallocate(_Myfirst, static_cast&lt;size_type&gt;(_Myend - _Myfirst));</span>
        }

<span style = "background-color:#fdd">        _Myfirst = _Newvec;
        _Mylast  = _Newvec + _Newsize;
        _Myend   = _Newvec + _Newcapacity;</span>
        _ASAN_VECTOR_CREATE;
<span style = "background-color:#fdd">    }</span>

<span style = "background-color:#fdd">    _CONSTEXPR20 void _Tidy() noexcept { // free all storage
        auto&amp; _Al         = _Getal();
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;</span>

<span style = "background-color:#fdd">        _My_data._Orphan_all();</span>

<span style = "background-color:#fdd">        if (_Myfirst) { // destroy and deallocate old array
            _STD _Destroy_range(_Myfirst, _Mylast, _Al);</span>
            _ASAN_VECTOR_REMOVE;
<span style = "background-color:#fdd">            _Al.deallocate(_Myfirst, static_cast&lt;size_type&gt;(_Myend - _Myfirst));</span>

<span style = "background-color:#fdd">            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;</span>
        }
<span style = "background-color:#fdd">    }</span>

    template &lt;class... _Valty&gt;
<span style = "background-color:#fdd">    _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&amp;&amp;... _Val) {</span>
        // Dispatches between the three sized constructions.
        // 1-arg -&gt; value-construction, e.g. vector(5)
        // 2-arg -&gt; fill, e.g. vector(5, "meow")
        // 3-arg -&gt; sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
<span style = "background-color:#fdd">        auto&amp; _Al       = _Getal();
        auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
        auto&amp; _My_data  = _Mypair._Myval2;
        _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _My_data);
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard&lt;vector&gt; _Guard{this};</span>
            if constexpr (sizeof...(_Val) == 0) {
<span style = "background-color:#fdd">                _My_data._Mylast = _STD _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);</span>
            } else if constexpr (sizeof...(_Val) == 1) {
                _STL_INTERNAL_STATIC_ASSERT(is_same_v&lt;_Valty..., const _Ty&amp;&gt;);
<span style = "background-color:#fdd">                _My_data._Mylast = _STD _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);</span>
            } else if constexpr (sizeof...(_Val) == 2) {
<span style = "background-color:#fdd">                _My_data._Mylast = _STD _Uninitialized_copy(_STD forward&lt;_Valty&gt;(_Val)..., _My_data._Myfirst, _Al);</span>
            } else {
                _STL_INTERNAL_STATIC_ASSERT(false); // unexpected number of arguments
            }
            _ASAN_VECTOR_CREATE;
<span style = "background-color:#fdd">            _Guard._Target = nullptr;
        }</span>

<span style = "background-color:#fdd">        _Proxy._Release();
    }</span>

    _CONSTEXPR20 void _Move_assign_unequal_alloc(vector&amp; _Right) {
        auto&amp; _Al         = _Getal();
        auto&amp; _My_data    = _Mypair._Myval2;
        auto&amp; _Right_data = _Right._Mypair._Myval2;

        const pointer _First = _Right_data._Myfirst;
        const pointer _Last  = _Right_data._Mylast;
        const auto _Newsize  = static_cast&lt;size_type&gt;(_Last - _First);

        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

        constexpr bool _Nothrow_construct =
            conjunction_v&lt;is_nothrow_move_constructible&lt;_Ty&gt;, _Uses_default_construct&lt;_Alloc, _Ty*, _Ty&gt;&gt;;

        _My_data._Orphan_all();
        const auto _Oldcapacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Myfirst);
        if (_Newsize &gt; _Oldcapacity) {
            _Clear_and_reserve_geometric(_Newsize);
            if constexpr (_Nothrow_construct) {
                _Mylast = _Uninitialized_move(_First, _Last, _Myfirst, _Al);
                _ASAN_VECTOR_CREATE;
            } else {
                _ASAN_VECTOR_CREATE_GUARD;
                _Mylast = _Uninitialized_move(_First, _Last, _Myfirst, _Al);
            }

            return;
        }

        const auto _Oldsize = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);
        if (_Newsize &gt; _Oldsize) {
            const pointer _Mid = _First + _Oldsize;
            _STD _Move_unchecked(_First, _Mid, _Myfirst);

            if constexpr (_Nothrow_construct) {
                _ASAN_VECTOR_MODIFY(static_cast&lt;difference_type&gt;(_Newsize - _Oldsize));
                _Mylast = _Uninitialized_move(_Mid, _Last, _Mylast, _Al);
            } else {
                _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
                _Mylast = _Uninitialized_move(_Mid, _Last, _Mylast, _Al);
                _ASAN_VECTOR_RELEASE_GUARD;
            }
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            _STD _Move_unchecked(_First, _Last, _Myfirst);
            _Destroy_range(_Newlast, _Mylast, _Al);
            _ASAN_VECTOR_MODIFY(static_cast&lt;difference_type&gt;(_Newsize - _Oldsize));
            _Mylast = _Newlast;
        }
    }

<span style = "background-color:#fdd">    [[noreturn]] static void _Xlength() {
        _Xlength_error("vector too long");
    }</span>

    [[noreturn]] static void _Xrange() {
        _Xout_of_range("invalid vector subscript");
    }

#if _ITERATOR_DEBUG_LEVEL == 2
<span style = "background-color:#fdd">    _CONSTEXPR20 void _Orphan_range_unlocked(pointer _First, pointer _Last) const {
        _Iterator_base12** _Pnext = &amp;_Mypair._Myval2._Myproxy-&gt;_Myfirstiter;
        while (*_Pnext) {
            const auto _Pnextptr = static_cast&lt;const_iterator&amp;&gt;(**_Pnext)._Ptr;
            const auto _Temp     = *_Pnext;
            if (_Pnextptr &lt; _First || _Last &lt; _Pnextptr) { // skip the iterator
                _Pnext = &amp;_Temp-&gt;_Mynextiter;
            } else { // orphan the iterator
                _Temp-&gt;_Myproxy = nullptr;
                *_Pnext         = _Temp-&gt;_Mynextiter;</span>
            }
<span style = "background-color:#fdd">        }
    }</span>

<span style = "background-color:#fdd">    void _Orphan_range_locked(pointer _First, pointer _Last) const {
        _Lockit _Lock(_LOCK_DEBUG);
        _Orphan_range_unlocked(_First, _Last);
    }</span>

<span style = "background-color:#fdd">    _CONSTEXPR20 void _Orphan_range(pointer _First, pointer _Last) const {</span>
        // orphan iterators within specified (inclusive) range
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            _Orphan_range_unlocked(_First, _Last);
        } else
#endif // _HAS_CXX20
        {
<span style = "background-color:#fdd">            _Orphan_range_locked(_First, _Last);</span>
        }
<span style = "background-color:#fdd">    }</span>
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
    _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}
#endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 _Alty&amp; _Getal() noexcept {
        return _Mypair._Get_first();
    }</span>

<span style = "background-color:#fdd">    _NODISCARD _CONSTEXPR20 const _Alty&amp; _Getal() const noexcept {
        return _Mypair._Get_first();
    }</span>

    _NODISCARD _CONSTEXPR20 iterator _Make_iterator(const pointer _Ptr) noexcept {
        return iterator(_Ptr, _STD addressof(_Mypair._Myval2));
    }

    _NODISCARD _CONSTEXPR20 iterator _Make_iterator_offset(const size_type _Offset) noexcept {
        // return the iterator begin() + _Offset without a debugging check
        auto&amp; _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst + _Offset, _STD addressof(_My_data));
    }

    _Compressed_pair&lt;_Alty, _Scary_val&gt; _Mypair;
};

#if _HAS_CXX17
template &lt;class _Iter, class _Alloc = allocator&lt;_Iter_value_t&lt;_Iter&gt;&gt;,
    enable_if_t&lt;conjunction_v&lt;_Is_iterator&lt;_Iter&gt;, _Is_allocator&lt;_Alloc&gt;&gt;, int&gt; = 0&gt;
vector(_Iter, _Iter, _Alloc = _Alloc()) -&gt; vector&lt;_Iter_value_t&lt;_Iter&gt;, _Alloc&gt;;
#endif // _HAS_CXX17

#if _HAS_CXX23
template &lt;_RANGES input_range _Rng, _Allocator_for_container _Alloc = allocator&lt;_RANGES range_value_t&lt;_Rng&gt;&gt;&gt;
vector(from_range_t, _Rng&amp;&amp;, _Alloc = _Alloc()) -&gt; vector&lt;_RANGES range_value_t&lt;_Rng&gt;, _Alloc&gt;;
#endif // _HAS_CXX23

template &lt;class _Alloc&gt;
class vector&lt;bool, _Alloc&gt;;

using _Vbase = unsigned int; // word type for vector&lt;bool&gt; representation

_INLINE_VAR constexpr int _VBITS = 8 * sizeof(_Vbase); // at least CHAR_BITS bits per word

_EXPORT_STD template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20 bool operator==(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    if (_Left.size() != _Right.size()) {
        return false;
    }

    if constexpr (is_same_v&lt;_Ty, bool&gt;) {
        return _STD equal(
            _Left._Myvec._Unchecked_begin(), _Left._Myvec._Unchecked_end(), _Right._Myvec._Unchecked_begin());
    } else {
        return _STD equal(_Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin());
    }
}

#if !_HAS_CXX20
template &lt;class _Ty, class _Alloc&gt;
_NODISCARD bool operator!=(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    return !(_Left == _Right);
}
#endif // !_HAS_CXX20

// Optimize vector&lt;bool&gt; lexicographical comparisons.

// There are several endianness/ordering issues to consider here.
// * Machine endianness is irrelevant. (That affects how an unsigned int is stored
//   as a sequence of bytes. While all of our supported architectures are little-endian,
//   that's irrelevant as long as we avoid reinterpreting unsigned int as a sequence of bytes.)
// * Appending bits to vector&lt;bool&gt; eventually appends words to its underlying storage.
//   For example, vb[10] is stored within vb._Myvec[0], while vb[100] is stored within vb._Myvec[3].
//   This allows us to translate lexicographical comparisons from theoretical bits to physical words.
// * Unsigned integers are written and compared as big-endian (most significant bit first).
//   For example, 0x10u &gt; 0x07u.
// * However, vector&lt;bool&gt; packs bits into words as little-endian (least significant bit first).
//   For example, vector&lt;bool&gt;{false, true, true, true} stores 0b0000'0000'0000'0000'0000'0000'0000'1110u.
// We could bit-reverse words before comparing, but we just need to find the least significant bit that differs.

template &lt;class _Ret&gt;
struct _Vbase_compare_three_way {
    _NODISCARD _STATIC_CALL_OPERATOR constexpr _Ret operator()(
        const _Vbase _Left, const _Vbase _Right) _CONST_CALL_OPERATOR noexcept {
        const _Vbase _Differing_bits = _Left ^ _Right;

        if (_Differing_bits == 0) { // improves _Countr_zero codegen below
#if _HAS_CXX20
            return strong_ordering::equal;
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
            return 0;
#endif // ^^^ !_HAS_CXX20 ^^^
        }

        const int _Bit_index = _Countr_zero(_Differing_bits); // number of least significant bits that match
        _STL_INTERNAL_CHECK(_Bit_index &lt; _VBITS); // because we return early for equality

        const _Vbase _Mask = _Vbase{1} &lt;&lt; _Bit_index; // selects the least significant bit that differs

        // Instead of comparing (_Left &amp; _Mask) to (_Right &amp; _Mask), we know that exactly one side will be zero.
#if _HAS_CXX20
        return (_Left &amp; _Mask) == 0 ? strong_ordering::less : strong_ordering::greater;
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
        return (_Left &amp; _Mask) == 0 ? -1 : 1;
#endif // ^^^ !_HAS_CXX20 ^^^
    }
};

#if _HAS_CXX20
_EXPORT_STD template &lt;class _Ty, class _Alloc&gt;
_NODISCARD constexpr _Synth_three_way_result&lt;_Ty&gt; operator&lt;=&gt;(
    const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    if constexpr (is_same_v&lt;_Ty, bool&gt;) {
        // This optimization works because vector&lt;bool&gt; "trims" its underlying storage by zeroing out unused bits.
        const auto _Min_word_size = (_STD min)(_Left._Myvec.size(), _Right._Myvec.size());
        const auto _Left_words    = _Left._Myvec._Unchecked_begin();
        const auto _Right_words   = _Right._Myvec._Unchecked_begin();

        using _Comp = _Vbase_compare_three_way&lt;strong_ordering&gt;;

        const strong_ordering _Word_comparison = _STD lexicographical_compare_three_way(
            _Left_words, _Left_words + _Min_word_size, _Right_words, _Right_words + _Min_word_size, _Comp{});

        if (_Word_comparison != 0) {
            return _Word_comparison;
        }

        return _Left.size() &lt;=&gt; _Right.size();
    } else {
        return _STD lexicographical_compare_three_way(_Left._Unchecked_begin(), _Left._Unchecked_end(),
            _Right._Unchecked_begin(), _Right._Unchecked_end(), _Synth_three_way{});
    }
}
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20 bool operator&lt;(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    if constexpr (is_same_v&lt;_Ty, bool&gt;) {
        // This optimization works because vector&lt;bool&gt; "trims" its underlying storage by zeroing out unused bits.
        auto _First = _Left._Myvec._Unchecked_begin();
        auto _Other = _Right._Myvec._Unchecked_begin();

        const auto _Last = _First + (_STD min)(_Left._Myvec.size(), _Right._Myvec.size());

        for (; _First != _Last; ++_First, (void) ++_Other) {
            using _Comp        = _Vbase_compare_three_way&lt;signed char&gt;;
            const auto _Result = _Comp{}(*_First, *_Other);

            if (_Result &lt; 0) {
                return true;
            } else if (_Result &gt; 0) {
                return false;
            }
        }

        return _Left.size() &lt; _Right.size();
    } else {
        return _STD lexicographical_compare(
            _Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin(), _Right._Unchecked_end());
    }
}

template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20 bool operator&gt;(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    return _Right &lt; _Left;
}

template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20 bool operator&lt;=(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    return !(_Right &lt; _Left);
}

template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20 bool operator&gt;=(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    return !(_Left &lt; _Right);
}
#endif // ^^^ !_HAS_CXX20 ^^^

_EXPORT_STD template &lt;class _Ty, class _Alloc&gt;
_CONSTEXPR20 void swap(vector&lt;_Ty, _Alloc&gt;&amp; _Left, vector&lt;_Ty, _Alloc&gt;&amp; _Right) noexcept /* strengthened */ {
    _Left.swap(_Right);
}

#if _HAS_CXX20
_EXPORT_STD template &lt;class _Ty, class _Alloc, class _Uty&gt;
constexpr vector&lt;_Ty, _Alloc&gt;::size_type erase(vector&lt;_Ty, _Alloc&gt;&amp; _Cont, const _Uty&amp; _Val) {
    return _STD _Erase_remove(_Cont, _Val);
}

_EXPORT_STD template &lt;class _Ty, class _Alloc, class _Pr&gt;
constexpr vector&lt;_Ty, _Alloc&gt;::size_type erase_if(vector&lt;_Ty, _Alloc&gt;&amp; _Cont, _Pr _Pred) {
    return _STD _Erase_remove_if(_Cont, _STD _Pass_fn(_Pred));
}
#endif // _HAS_CXX20

template &lt;class _Alloc0&gt;
struct _Wrap_alloc { // TRANSITION, ABI compat, preserves symbol names of vector&lt;bool&gt;::iterator
    using _Alloc = _Alloc0;
};

template &lt;class _Alvbase_wrapped&gt;
class _Vb_iter_base : public _Iterator_base {
    // store information common to reference and iterators
public:
    using _Alvbase         = typename _Alvbase_wrapped::_Alloc;
    using _Size_type       = typename allocator_traits&lt;_Alvbase&gt;::size_type;
    using _Difference_type = typename allocator_traits&lt;_Alvbase&gt;::difference_type;
    using _Mycont          = vector&lt;bool, _Rebind_alloc_t&lt;_Alvbase, bool&gt;&gt;;

    static constexpr _Difference_type _VBITS_DIFF = _VBITS;

    _CONSTEXPR20 _Vb_iter_base() = default;

    _CONSTEXPR20 _Vb_iter_base(const _Vbase* _Ptr, _Size_type _Off, const _Container_base* _Mypvbool) noexcept
        : _Myptr(_Ptr), _Myoff(_Off) {
        this-&gt;_Adopt(_Mypvbool);
    }

    _CONSTEXPR20 void _Advance(_Size_type _Off) noexcept {
        _Myoff += _Off;
        _Myptr += _Myoff / _VBITS;
        _Myoff %= _VBITS;
    }

#if _ITERATOR_DEBUG_LEVEL != 0
    _CONSTEXPR20 _Difference_type _Total_off(const _Mycont* _Cont) const noexcept {
        return static_cast&lt;_Difference_type&gt;(_VBITS_DIFF * (_Myptr - _Cont-&gt;_Myvec.data()) + _Myoff);
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

    const _Vbase* _Myptr = nullptr;
    _Size_type _Myoff    = 0;
};

template &lt;class _Alvbase_wrapped&gt;
class _Vb_reference : public _Vb_iter_base&lt;_Alvbase_wrapped&gt; {
    // reference to a bit within a base word
private:
    using _Mybase          = _Vb_iter_base&lt;_Alvbase_wrapped&gt;;
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;

public:
    _CONSTEXPR20 _Vb_reference(const _Vb_reference&amp;) = default;

    _CONSTEXPR20 _Vb_reference(const _Mybase&amp; _Right) noexcept
        : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) {}

    _CONSTEXPR20 _Vb_reference&amp; operator=(const _Vb_reference&amp; _Right) noexcept {
        return *this = static_cast&lt;bool&gt;(_Right);
    }

    _CONSTEXPR20 _Vb_reference&amp; operator=(bool _Val) noexcept {
        if (_Val) {
            *const_cast&lt;_Vbase*&gt;(_Getptr()) |= _Mask();
        } else {
            *const_cast&lt;_Vbase*&gt;(_Getptr()) &amp;= ~_Mask();
        }

        return *this;
    }

#if _HAS_CXX23
    constexpr const _Vb_reference&amp; operator=(bool _Val) const noexcept {
        if (_Val) {
            *const_cast&lt;_Vbase*&gt;(_Getptr()) |= _Mask();
        } else {
            *const_cast&lt;_Vbase*&gt;(_Getptr()) &amp;= ~_Mask();
        }

        return *this;
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 void flip() noexcept {
        *const_cast&lt;_Vbase*&gt;(_Getptr()) ^= _Mask();
    }

    _CONSTEXPR20 operator bool() const noexcept {
        return (*_Getptr() &amp; _Mask()) != 0;
    }

    _CONSTEXPR20 const _Vbase* _Getptr() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Cont, "cannot dereference value-initialized vector&lt;bool&gt; iterator");
        _STL_VERIFY(this-&gt;_Total_off(_Cont) &lt;= static_cast&lt;_Difference_type&gt;(_Cont-&gt;_Mysize),
            "vector&lt;bool&gt; iterator not dereferenceable");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return this-&gt;_Myptr;
    }

    friend _CONSTEXPR20 void swap(_Vb_reference _Left, _Vb_reference _Right) noexcept {
        bool _Val = _Left; // NOT _STD swap
        _Left     = _Right;
        _Right    = _Val;
    }

protected:
    _CONSTEXPR20 _Vbase _Mask() const noexcept {
        return static_cast&lt;_Vbase&gt;(1) &lt;&lt; this-&gt;_Myoff;
    }
};

template &lt;class _Alvbase_wrapped&gt;
class _Vb_const_iterator : public _Vb_iter_base&lt;_Alvbase_wrapped&gt; {
public:
    using _Mybase         = _Vb_iter_base&lt;_Alvbase_wrapped&gt;;
    using _Mycont         = typename _Mybase::_Mycont;
    using _Size_type      = typename _Mybase::_Size_type;
    using _Reft           = _Vb_reference&lt;_Alvbase_wrapped&gt;;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::_Difference_type;
    using pointer           = const_reference*;
    using reference         = const_reference;

    _CONSTEXPR20 _Vb_const_iterator() = default;

    _CONSTEXPR20 _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool) noexcept
        : _Mybase(_Ptr, 0, _Mypvbool) {}

    _NODISCARD _CONSTEXPR20 const_reference operator*() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Cont, "cannot dereference value-initialized vector&lt;bool&gt; iterator");
        _STL_VERIFY(this-&gt;_Total_off(_Cont) &lt; static_cast&lt;difference_type&gt;(_Cont-&gt;_Mysize),
            "vector&lt;bool&gt; iterator not dereferenceable");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Reft(*this);
    }

    _CONSTEXPR20 _Vb_const_iterator&amp; operator++() noexcept {
        _Inc();
        return *this;
    }

    _CONSTEXPR20 _Vb_const_iterator operator++(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Inc();
        return _Tmp;
    }

    _CONSTEXPR20 _Vb_const_iterator&amp; operator--() noexcept {
        _Dec();
        return *this;
    }

    _CONSTEXPR20 _Vb_const_iterator operator--(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Dec();
        return _Tmp;
    }

    _CONSTEXPR20 _Vb_const_iterator&amp; operator+=(const difference_type _Off) noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        if (_Off != 0) {
            const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
            _STL_VERIFY(_Cont, "cannot seek value-initialized vector&lt;bool&gt; iterator");
            const auto _Start_offset = this-&gt;_Total_off(_Cont);
            if (_Off &lt; 0) {
                _STL_VERIFY(-_Start_offset &lt;= _Off, "cannot seek vector&lt;bool&gt; iterator before begin");
            } else if (0 &lt; _Off) {
                _STL_VERIFY(_Off &lt;= static_cast&lt;difference_type&gt;(_Cont-&gt;_Mysize - _Start_offset),
                    "cannot seek vector&lt;bool&gt; iterator after end");
            }
        }
#endif // _ITERATOR_DEBUG_LEVEL != 0

        if (_Off &lt; 0 &amp;&amp; this-&gt;_Myoff &lt; 0 - static_cast&lt;_Size_type&gt;(_Off)) { // add negative increment
            this-&gt;_Myoff += static_cast&lt;_Size_type&gt;(_Off);
            this-&gt;_Myptr -= 1 + (static_cast&lt;_Size_type&gt;(-1) - this-&gt;_Myoff) / _VBITS;
            this-&gt;_Myoff %= _VBITS;
        } else { // add non-negative increment
            this-&gt;_Myoff += static_cast&lt;_Size_type&gt;(_Off);
            this-&gt;_Myptr += this-&gt;_Myoff / _VBITS;
            this-&gt;_Myoff %= _VBITS;
        }
        return *this;
    }

    _NODISCARD _CONSTEXPR20 _Vb_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    _NODISCARD friend _CONSTEXPR20 _Vb_const_iterator operator+(
        const difference_type _Off, _Vb_const_iterator _Right) noexcept {
        _Right += _Off;
        return _Right;
    }

    _CONSTEXPR20 _Vb_const_iterator&amp; operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    _NODISCARD _CONSTEXPR20 _Vb_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20 difference_type operator-(const _Vb_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return static_cast&lt;difference_type&gt;(_Mybase::_VBITS_DIFF * (this-&gt;_Myptr - _Right._Myptr))
             + static_cast&lt;difference_type&gt;(this-&gt;_Myoff) - static_cast&lt;difference_type&gt;(_Right._Myoff);
    }

    _NODISCARD _CONSTEXPR20 const_reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    _NODISCARD _CONSTEXPR20 bool operator==(const _Vb_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return this-&gt;_Myptr == _Right._Myptr &amp;&amp; this-&gt;_Myoff == _Right._Myoff;
    }

#if _HAS_CXX20
    _NODISCARD constexpr strong_ordering operator&lt;=&gt;(const _Vb_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        if (const auto _CmpResult = this-&gt;_Myptr &lt;=&gt; _Right._Myptr; _CmpResult != 0) {
            return _CmpResult;
        }
        return this-&gt;_Myoff &lt;=&gt; _Right._Myoff;
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD bool operator!=(const _Vb_const_iterator&amp; _Right) const noexcept {
        return !(*this == _Right);
    }

    _NODISCARD bool operator&lt;(const _Vb_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return this-&gt;_Myptr &lt; _Right._Myptr || (this-&gt;_Myptr == _Right._Myptr &amp;&amp; this-&gt;_Myoff &lt; _Right._Myoff);
    }

    _NODISCARD bool operator&gt;(const _Vb_const_iterator&amp; _Right) const noexcept {
        return _Right &lt; *this;
    }

    _NODISCARD bool operator&lt;=(const _Vb_const_iterator&amp; _Right) const noexcept {
        return !(_Right &lt; *this);
    }

    _NODISCARD bool operator&gt;=(const _Vb_const_iterator&amp; _Right) const noexcept {
        return !(*this &lt; _Right);
    }
#endif // ^^^ !_HAS_CXX20 ^^^

    _CONSTEXPR20 void _Compat(const _Vb_const_iterator&amp; _Right) const noexcept {
        // test for compatible iterator pair
#if _ITERATOR_DEBUG_LEVEL == 0
        (void) _Right;
#else
        _STL_VERIFY(this-&gt;_Getcont() == _Right._Getcont(), "vector&lt;bool&gt; iterators incompatible");
#endif
    }

#if _ITERATOR_DEBUG_LEVEL != 0
    using _Prevent_inheriting_unwrap = _Vb_const_iterator;

    friend _CONSTEXPR20 void _Verify_range(const _Vb_const_iterator&amp; _First, const _Vb_const_iterator&amp; _Last) noexcept {
        // note _Compat check inside &lt;=
        _STL_VERIFY(_First &lt;= _Last, "vector&lt;bool&gt; iterator range transposed");
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

    _CONSTEXPR20 void _Dec() noexcept { // decrement bit position
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Cont, "cannot decrement value-initialized vector&lt;bool&gt; iterator");
        _STL_VERIFY(this-&gt;_Total_off(_Cont) &gt; 0, "cannot decrement vector&lt;bool&gt; begin iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        if (this-&gt;_Myoff != 0) {
            --this-&gt;_Myoff;
        } else { // move to previous word
            this-&gt;_Myoff = _VBITS - 1;
            --this-&gt;_Myptr;
        }
    }

    _CONSTEXPR20 void _Inc() noexcept { // increment bit position
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Cont, "cannot increment value-initialized vector&lt;bool&gt; iterator");
        _STL_VERIFY(this-&gt;_Total_off(_Cont) &lt; static_cast&lt;difference_type&gt;(_Cont-&gt;_Mysize),
            "cannot increment vector&lt;bool&gt; end iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        if (this-&gt;_Myoff &lt; _VBITS - 1) {
            ++this-&gt;_Myoff;
        } else { // move to next word
            this-&gt;_Myoff = 0;
            ++this-&gt;_Myptr;
        }
    }
};

template &lt;class _Alvbase_wrapped&gt;
class _Vb_iterator : public _Vb_const_iterator&lt;_Alvbase_wrapped&gt; {
public:
    using _Mybase = _Vb_const_iterator&lt;_Alvbase_wrapped&gt;;
    using _Mycont = typename _Mybase::_Mycont;

    using _Reft           = _Vb_reference&lt;_Alvbase_wrapped&gt;;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::difference_type;
    using pointer           = _Reft*;
    using reference         = _Reft;

    using _Mybase::_Mybase;

    _NODISCARD _CONSTEXPR20 reference operator*() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Cont, "cannot dereference value-initialized vector&lt;bool&gt; iterator");
        _STL_VERIFY(this-&gt;_Total_off(_Cont) &lt; static_cast&lt;difference_type&gt;(_Cont-&gt;_Mysize),
            "vector&lt;bool&gt; iterator not dereferenceable");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Reft(*this);
    }

    _CONSTEXPR20 _Vb_iterator&amp; operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    _CONSTEXPR20 _Vb_iterator operator++(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _CONSTEXPR20 _Vb_iterator&amp; operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _CONSTEXPR20 _Vb_iterator operator--(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    _CONSTEXPR20 _Vb_iterator&amp; operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    _NODISCARD _CONSTEXPR20 _Vb_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    _NODISCARD friend _CONSTEXPR20 _Vb_iterator operator+(const difference_type _Off, _Vb_iterator _Right) noexcept {
        _Right += _Off;
        return _Right;
    }

    _CONSTEXPR20 _Vb_iterator&amp; operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    _NODISCARD _CONSTEXPR20 _Vb_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20 reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    using _Prevent_inheriting_unwrap = _Vb_iterator;
};

template &lt;class _Alloc&gt;
class _Vb_val : public _Container_base {
public:
    using _Alvbase         = _Rebind_alloc_t&lt;_Alloc, _Vbase&gt;;
    using _Alvbase_traits  = allocator_traits&lt;_Alvbase&gt;;
    using _Vectype         = vector&lt;_Vbase, _Alvbase&gt;;
    using _Alvbase_wrapped = _Wrap_alloc&lt;_Alvbase&gt;;
    using size_type        = typename _Alvbase_traits::size_type;

    _CONSTEXPR20 _Vb_val() noexcept(is_nothrow_default_constructible_v&lt;_Vectype&gt;) : _Myvec(), _Mysize(0) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20 _Vb_val(const _Alloc&amp; _Al) noexcept : _Myvec(static_cast&lt;_Alvbase&gt;(_Al)), _Mysize(0) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20 _Vb_val(size_type _Count, const bool&amp; _Val)
        : _Myvec(_Nw(_Count), static_cast&lt;_Vbase&gt;(_Val ? -1 : 0)), _Mysize(0) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20 _Vb_val(size_type _Count, const bool&amp; _Val, const _Alloc&amp; _Al)
        : _Myvec(_Nw(_Count), static_cast&lt;_Vbase&gt;(_Val ? -1 : 0), static_cast&lt;_Alvbase&gt;(_Al)), _Mysize(0) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20 _Vb_val(const _Vb_val&amp; _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20 _Vb_val(const _Vb_val&amp; _Right, const _Alloc&amp; _Al)
        : _Myvec(_Right._Myvec, static_cast&lt;_Alvbase&gt;(_Al)), _Mysize(_Right._Mysize) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20 _Vb_val(_Vb_val&amp;&amp; _Right) noexcept(is_nothrow_move_constructible_v&lt;_Vectype&gt;)
        : _Myvec(_STD move(_Right._Myvec)), _Mysize(_STD exchange(_Right._Mysize, size_type{0})) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20 _Vb_val(_Vb_val&amp;&amp; _Right, const _Alloc&amp; _Al)
        noexcept(is_nothrow_constructible_v&lt;_Vectype, _Vectype, _Alvbase&gt;)
        : _Myvec(_STD move(_Right._Myvec), static_cast&lt;_Alvbase&gt;(_Al)), _Mysize(_Right._Mysize) {
        if (_Right._Myvec.empty()) {
            // we took _Right's buffer, so zero out size
            _Right._Mysize = 0;
        }

        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20 ~_Vb_val() noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        this-&gt;_Orphan_all();
        auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alvbase, this-&gt;_Getal());
        _Delete_plain_internal(_Alproxy, _STD exchange(this-&gt;_Myproxy, nullptr));
#endif // _ITERATOR_DEBUG_LEVEL != 0

#if _MSVC_STL_DESTRUCTOR_TOMBSTONES
        // Destroying _Myvec will store tombstones in its pointers, setting its apparent size to 0.
        // We should also set our _Mysize to 0 for consistency, allowing precondition hardening to detect UB earlier.
        _Mysize = 0;
#endif
    }

    _CONSTEXPR20 _Alvbase&amp; _Getal() noexcept {
        return _Myvec._Getal();
    }

    _CONSTEXPR20 const _Alvbase&amp; _Getal() const noexcept {
        return _Myvec._Getal();
    }

    static _CONSTEXPR20 size_type _Nw(size_type _Count) noexcept {
        return (_Count + _VBITS - 1) / _VBITS;
    }

    _CONSTEXPR20 void _Emplace_back_unchecked(const _Vbase _Val) noexcept {
        _STL_INTERNAL_CHECK(_Myvec.size() &lt; _Myvec.capacity());
        _Myvec._Emplace_back_with_unused_capacity(_Val);
    }

    _Vectype _Myvec; // base vector of words
    size_type _Mysize; // current length of sequence
};

template &lt;class _Alloc&gt;
class vector&lt;bool, _Alloc&gt; : public _Vb_val&lt;_Alloc&gt; {
public:
    static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v&lt;bool, typename _Alloc::value_type&gt;,
        _MISMATCHED_ALLOCATOR_MESSAGE("vector&lt;bool, Allocator&gt;", "bool"));

    using _Mybase          = _Vb_val&lt;_Alloc&gt;;
    using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
    using _Alvbase         = typename _Mybase::_Alvbase;
    using _Alvbase_traits  = typename _Mybase::_Alvbase_traits;

    using size_type       = typename _Alvbase_traits::size_type;
    using difference_type = typename _Alvbase_traits::difference_type;
    using allocator_type  = _Alloc;

    using reference       = _Vb_reference&lt;_Alvbase_wrapped&gt;;
    using const_reference = bool;
    using value_type      = bool;

    using _Reft          = reference;
    using iterator       = _Vb_iterator&lt;_Alvbase_wrapped&gt;;
    using const_iterator = _Vb_const_iterator&lt;_Alvbase_wrapped&gt;;

    using pointer                = iterator;
    using const_pointer          = const_iterator;
    using reverse_iterator       = _STD reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = _STD reverse_iterator&lt;const_iterator&gt;;

    enum { _EEN_VBITS = _VBITS }; // helper for expression evaluator

    _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v&lt;_Alloc&gt;) : _Mybase(_Alloc()) {}

    _CONSTEXPR20 explicit vector(const _Alloc&amp; _Al) noexcept : _Mybase(_Al) {}

    _CONSTEXPR20 explicit vector(_CRT_GUARDOVERFLOW size_type _Count, const _Alloc&amp; _Al = _Alloc())
        : _Mybase(_Count, false, _Al) {
        _Trim(_Count);
    }

    _CONSTEXPR20 vector(_CRT_GUARDOVERFLOW size_type _Count, const bool&amp; _Val, const _Alloc&amp; _Al = _Alloc())
        : _Mybase(_Count, _Val, _Al) {
        _Trim(_Count);
    }

    _CONSTEXPR20 vector(const vector&amp; _Right) : _Mybase(_Right) {}

    _CONSTEXPR20 vector(const vector&amp; _Right, const _Identity_t&lt;_Alloc&gt;&amp; _Al) : _Mybase(_Right, _Al) {}

    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20 vector(_Iter _First, _Iter _Last, const _Alloc&amp; _Al = _Alloc()) : _Mybase(_Al) {
        insert(begin(), _First, _Last);
    }

#if _HAS_CXX23
    template &lt;_Container_compatible_range&lt;bool&gt; _Rng&gt;
    constexpr vector(from_range_t, _Rng&amp;&amp; _Range, const _Alloc&amp; _Al = _Alloc()) : _Mybase(_Al) {
        if constexpr (_RANGES forward_range&lt;_Rng&gt; || _RANGES sized_range&lt;_Rng&gt;) {
            const auto _Length = _To_unsigned_like(_RANGES distance(_Range));
            const auto _Count  = _Convert_size&lt;size_type&gt;(_Length);
            _Assign_counted_range(_RANGES _Ubegin(_Range), _Count);
        } else {
            _Assign_uncounted_range(_RANGES _Ubegin(_Range), _RANGES _Uend(_Range));
        }
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 vector(vector&amp;&amp; _Right) noexcept : _Mybase(_STD move(_Right)) {
        this-&gt;_Swap_proxy_and_iterators(_Right);
    }

    _CONSTEXPR20 vector(vector&amp;&amp; _Right, const _Identity_t&lt;_Alloc&gt;&amp; _Al)
        noexcept(is_nothrow_constructible_v&lt;_Mybase, _Mybase, const _Alloc&amp;&gt;) // strengthened
        : _Mybase(_STD move(_Right), _Al) {
        if constexpr (!_Alvbase_traits::is_always_equal::value) {
            if (this-&gt;_Getal() != _Right._Getal()) {
                return;
            }
        }

        this-&gt;_Swap_proxy_and_iterators(_Right);
    }

    _CONSTEXPR20 vector&amp; operator=(vector&amp;&amp; _Right)
        noexcept(_Choose_pocma_v&lt;_Alvbase&gt; != _Pocma_values::_No_propagate_allocators) {
        if (this == _STD addressof(_Right)) {
            return *this;
        }

#if _ITERATOR_DEBUG_LEVEL == 0
        this-&gt;_Myvec  = _STD move(_Right._Myvec);
        this-&gt;_Mysize = _STD exchange(_Right._Mysize, size_type{0});
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
        this-&gt;_Orphan_all();
        auto&amp; _Al                 = this-&gt;_Getal();
        auto&amp; _Right_al           = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v&lt;_Alvbase&gt;;
        if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
            using _Alproxy_type = _Rebind_alloc_t&lt;_Alvbase, _Container_proxy&gt;;
            if (_Al != _Right_al) { // reload proxy
                // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
                _Alproxy_type _Oldal(_Al);
                _Alproxy_type _Right_proxy_al(_Right_al);
                _Container_proxy_ptr&lt;_Alvbase&gt; _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
                this-&gt;_Myvec  = _STD move(_Right._Myvec);
                this-&gt;_Mysize = _STD exchange(_Right._Mysize, size_type{0});
                _Proxy._Bind(_Oldal, this);
                this-&gt;_Swap_proxy_and_iterators(_Right);
                return *this;
            }
        } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            this-&gt;_Myvec  = _STD move(_Right._Myvec);
            this-&gt;_Mysize = _Right._Mysize;
            if (_Right._Myvec.empty()) {
                // we took _Right's buffer, so zero out size
                _Right._Mysize = 0;
            }

            if (_Al == _Right_al) {
                this-&gt;_Swap_proxy_and_iterators(_Right);
            }
            return *this;
        }

        this-&gt;_Myvec  = _STD move(_Right._Myvec);
        this-&gt;_Mysize = _STD exchange(_Right._Mysize, size_type{0});
        this-&gt;_Swap_proxy_and_iterators(_Right);

#endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
        return *this;
    }

    template &lt;class... _Valty&gt;
    _CONSTEXPR20 _CONTAINER_EMPLACE_RETURN emplace_back(_Valty&amp;&amp;... _Val) {
        bool _Tmp(_STD forward&lt;_Valty&gt;(_Val)...);
        push_back(_Tmp);

#if _HAS_CXX17
        return back();
#endif // _HAS_CXX17
    }

    template &lt;class... _Valty&gt;
    _CONSTEXPR20 iterator emplace(const_iterator _Where, _Valty&amp;&amp;... _Val) {
        bool _Tmp(_STD forward&lt;_Valty&gt;(_Val)...);
        return insert(_Where, _Tmp);
    }

    _CONSTEXPR20 vector(initializer_list&lt;bool&gt; _Ilist, const _Alloc&amp; _Al = allocator_type()) : _Mybase(0, false, _Al) {
        insert(begin(), _Ilist.begin(), _Ilist.end());
    }

    _CONSTEXPR20 vector&amp; operator=(initializer_list&lt;bool&gt; _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    _CONSTEXPR20 void assign(initializer_list&lt;bool&gt; _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
    }

    _CONSTEXPR20 iterator insert(const_iterator _Where, initializer_list&lt;bool&gt; _Ilist) {
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    _CONSTEXPR20 ~vector() noexcept {}

    _CONSTEXPR20 vector&amp; operator=(const vector&amp; _Right) {
        if (this == _STD addressof(_Right)) {
            return *this;
        }

#if _ITERATOR_DEBUG_LEVEL == 0
        this-&gt;_Myvec  = _Right._Myvec;
        this-&gt;_Mysize = _Right._Mysize;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
        this-&gt;_Orphan_all();
        auto&amp; _Al       = this-&gt;_Getal();
        auto&amp; _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v&lt;_Alvbase&gt;) {
            if (_Al != _Right_al) {
                // reload proxy
                using _Alproxy_type = _Rebind_alloc_t&lt;_Alvbase, _Container_proxy&gt;;
                _Alproxy_type _Oldal(_Al);
                _Alproxy_type _Right_proxy_al(_Right_al);
                _Container_proxy_ptr&lt;_Alvbase&gt; _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
                this-&gt;_Myvec  = _Right._Myvec;
                this-&gt;_Mysize = _Right._Mysize;
                _Proxy._Bind(_Oldal, this);
                return *this;
            }
        }

        this-&gt;_Myvec  = _Right._Myvec;
        this-&gt;_Mysize = _Right._Mysize;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^

        return *this;
    }

    _CONSTEXPR20 void reserve(_CRT_GUARDOVERFLOW size_type _Count) {
        this-&gt;_Myvec.reserve(this-&gt;_Nw(_Count));
    }

    _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {
        return this-&gt;_Myvec.capacity() * _VBITS;
    }

    _NODISCARD _CONSTEXPR20 iterator begin() noexcept {
        return iterator(this-&gt;_Myvec.data(), this);
    }

    _NODISCARD _CONSTEXPR20 const_iterator begin() const noexcept {
        return const_iterator(this-&gt;_Myvec.data(), this);
    }

    _NODISCARD _CONSTEXPR20 iterator end() noexcept {
        return begin() + static_cast&lt;difference_type&gt;(this-&gt;_Mysize);
    }

    _NODISCARD _CONSTEXPR20 const_iterator end() const noexcept {
        return begin() + static_cast&lt;difference_type&gt;(this-&gt;_Mysize);
    }

    _NODISCARD _CONSTEXPR20 const_iterator cbegin() const noexcept {
        return begin();
    }

    _NODISCARD _CONSTEXPR20 const_iterator cend() const noexcept {
        return end();
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator crend() const noexcept {
        return rend();
    }

    _NODISCARD _CONSTEXPR20 iterator _Unchecked_begin() noexcept {
        return iterator(this-&gt;_Myvec.data(), this);
    }

    _NODISCARD _CONSTEXPR20 const_iterator _Unchecked_begin() const noexcept {
        return const_iterator(this-&gt;_Myvec.data(), this);
    }

    _NODISCARD _CONSTEXPR20 iterator _Unchecked_end() noexcept {
        return _Unchecked_begin() + static_cast&lt;difference_type&gt;(this-&gt;_Mysize);
    }

    _NODISCARD _CONSTEXPR20 const_iterator _Unchecked_end() const noexcept {
        return _Unchecked_begin() + static_cast&lt;difference_type&gt;(this-&gt;_Mysize);
    }

    _CONSTEXPR20 void shrink_to_fit() {
        if (this-&gt;_Myvec.capacity() != this-&gt;_Myvec.size()) {
            this-&gt;_Orphan_all();
            this-&gt;_Myvec.shrink_to_fit();
        }
    }

    _CONSTEXPR20 iterator _Make_iter(const_iterator _Where) noexcept {
        iterator _Tmp = begin();
        if (0 &lt; this-&gt;_Mysize) {
            _Tmp += _Where - begin();
        }

        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20 reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    _NODISCARD _CONSTEXPR20 reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW size_type _Newsize, bool _Val = false) {
        if (size() &lt; _Newsize) {
            _Insert_n(end(), _Newsize - size(), _Val);
        } else if (_Newsize &lt; size()) {
            erase(begin() + static_cast&lt;difference_type&gt;(_Newsize), end());
        }
    }

    _NODISCARD _CONSTEXPR20 size_type size() const noexcept {
        return this-&gt;_Mysize;
    }

    _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {
        constexpr auto _Diff_max  = static_cast&lt;size_type&gt;(_STD _Max_limit&lt;difference_type&gt;());
        const size_type _Ints_max = this-&gt;_Myvec.max_size();
        if (_Ints_max &gt; _Diff_max / _VBITS) { // max_size bound by difference_type limits
            return _Diff_max;
        }

        // max_size bound by underlying storage limits
        return _Ints_max * _VBITS;
    }

    _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {
        return this-&gt;_Mysize == 0;
    }

    _NODISCARD _CONSTEXPR20 allocator_type get_allocator() const noexcept {
        return static_cast&lt;allocator_type&gt;(this-&gt;_Myvec.get_allocator());
    }

    _NODISCARD _CONSTEXPR20 const_reference at(size_type _Off) const {
        if (size() &lt;= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    _NODISCARD _CONSTEXPR20 reference at(size_type _Off) {
        if (size() &lt;= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    _NODISCARD _CONSTEXPR20 const_reference operator[](size_type _Off) const noexcept /* strengthened */ {
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Off &lt; this-&gt;_Mysize, "vector&lt;bool&gt; subscript out of range");
#endif

        const_iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    _NODISCARD _CONSTEXPR20 reference operator[](size_type _Off) noexcept /* strengthened */ {
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Off &lt; this-&gt;_Mysize, "vector&lt;bool&gt; subscript out of range");
#endif

        iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    _NODISCARD _CONSTEXPR20 reference front() noexcept /* strengthened */ {
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(this-&gt;_Mysize != 0, "front() called on empty vector&lt;bool&gt;");
#endif

        return *begin();
    }

    _NODISCARD _CONSTEXPR20 const_reference front() const noexcept /* strengthened */ {
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(this-&gt;_Mysize != 0, "front() called on empty vector&lt;bool&gt;");
#endif

        return *begin();
    }

    _NODISCARD _CONSTEXPR20 reference back() noexcept /* strengthened */ {
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(this-&gt;_Mysize != 0, "back() called on empty vector&lt;bool&gt;");
#endif

        return *(end() - 1);
    }

    _NODISCARD _CONSTEXPR20 const_reference back() const noexcept /* strengthened */ {
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(this-&gt;_Mysize != 0, "back() called on empty vector&lt;bool&gt;");
#endif

        return *(end() - 1);
    }

    _CONSTEXPR20 void push_back(const bool&amp; _Val) {
        insert(end(), _Val);
    }

#if _HAS_CXX23
    template &lt;_Container_compatible_range&lt;bool&gt; _Rng&gt;
    constexpr void append_range(_Rng&amp;&amp; _Range) {
        insert_range(end(), _STD forward&lt;_Rng&gt;(_Range));
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 void pop_back() noexcept /* strengthened */ {
#if _MSVC_STL_HARDENING_VECTOR || _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(this-&gt;_Mysize != 0, "pop_back() called on empty vector&lt;bool&gt;");
#endif

        erase(end() - 1);
    }

    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20 void assign(_Iter _First, _Iter _Last) {
        clear();
        insert(begin(), _First, _Last);
    }

#if _HAS_CXX23
    template &lt;class _Iter&gt;
    constexpr void _Assign_counted_range(_Iter _First, const size_type _Count) {
        _STL_INTERNAL_CHECK(this-&gt;_Myvec.empty());
        this-&gt;_Myvec.reserve(this-&gt;_Nw(_Count));
        _Vbase _Accum = 0;
        _Vbase _Mask  = 1;
        for (size_type _Idx = 0; _Idx &lt; _Count; ++_Idx) {
            const bool _Tmp = *_First;
            ++_First;
            _Accum |= _Tmp ? _Mask : _Vbase{0};
            if ((_Mask &lt;&lt;= 1) == 0) {
                this-&gt;_Emplace_back_unchecked(_Accum);
                _Accum = 0;
                _Mask  = 1;
            }
        }

        if (_Count % _VBITS != 0) {
            this-&gt;_Emplace_back_unchecked(_Accum);
        }
        this-&gt;_Mysize = _Count;
    }

    template &lt;class _Iter, class _Sent&gt;
    constexpr void _Assign_uncounted_range(_Iter _First, const _Sent _Last) {
        _STL_INTERNAL_CHECK(this-&gt;_Myvec.empty());
        size_type _Count = 0;
        _Vbase _Accum    = 0;
        _Vbase _Mask     = 1;
        for (; _First != _Last; ++_Count) {
            const bool _Tmp = *_First;
            ++_First;
            _Accum |= _Tmp ? _Mask : _Vbase{0};
            if ((_Mask &lt;&lt;= 1) == 0) {
                this-&gt;_Myvec.push_back(_Accum);
                _Accum = 0;
                _Mask  = 1;
            }
        }

        if (_Count % _VBITS != 0) {
            this-&gt;_Myvec.push_back(_Accum);
        }
        this-&gt;_Mysize = _Count;
    }

    template &lt;_Container_compatible_range&lt;bool&gt; _Rng&gt;
    constexpr void assign_range(_Rng&amp;&amp; _Range) {
        static_assert(assignable_from&lt;bool&amp;, _RANGES range_reference_t&lt;_Rng&gt;&gt;,
            "Elements must be assignable from the range's reference type (N4993 [sequence.reqmts]/60).");
        clear();
        if constexpr (_RANGES forward_range&lt;_Rng&gt; || _RANGES sized_range&lt;_Rng&gt;) {
            const auto _Length = _To_unsigned_like(_RANGES distance(_Range));
            const auto _Count  = _Convert_size&lt;size_type&gt;(_Length);
            _Assign_counted_range(_RANGES _Ubegin(_Range), _Count);
        } else {
            _Assign_uncounted_range(_RANGES _Ubegin(_Range), _RANGES _Uend(_Range));
        }
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 void assign(_CRT_GUARDOVERFLOW size_type _Count, const bool&amp; _Val) {
        clear();
        _Insert_n(begin(), _Count, _Val);
    }

    _CONSTEXPR20 iterator insert(const_iterator _Where, const bool&amp; _Val) {
        return _Insert_n(_Where, size_type{1}, _Val);
    }

    _CONSTEXPR20 iterator insert(const_iterator _Where, _CRT_GUARDOVERFLOW size_type _Count, const bool&amp; _Val) {
        return _Insert_n(_Where, _Count, _Val);
    }

    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20 iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        const difference_type _Saved_offset = _Where - begin();
        _STD _Adl_verify_range(_First, _Last);
        auto _UFirst      = _STD _Get_unwrapped(_First);
        const auto _ULast = _STD _Get_unwrapped(_Last);

        if constexpr (_Is_cpp17_fwd_iter_v&lt;_Iter&gt;) {
            const auto _Length = static_cast&lt;size_t&gt;(_STD distance(_UFirst, _ULast));
            const auto _Count  = _STD _Convert_size&lt;size_type&gt;(_Length);
            const auto _Off    = static_cast&lt;difference_type&gt;(_Insert_x(_Where, _Count));
            _STD _Copy_unchecked(_UFirst, _ULast, begin() + _Off);
#if _HAS_CXX20
        } else if constexpr (forward_iterator&lt;_Iter&gt;) {
            const auto _Length = _STD _To_unsigned_like(_RANGES distance(_UFirst, _ULast));
            const auto _Count  = _STD _Convert_size&lt;size_type&gt;(_Length);
            const auto _Off    = static_cast&lt;difference_type&gt;(_Insert_x(_Where, _Count));
            _STD _Copy_unchecked(_UFirst, _ULast, begin() + _Off);
#endif // _HAS_CXX20
        } else {
            const auto _Old_size = this-&gt;_Mysize;
            for (; _UFirst != _ULast; ++_UFirst) {
                emplace_back(*_UFirst);
            }
#if _ITERATOR_DEBUG_LEVEL == 2
            _Orphan_range(static_cast&lt;size_type&gt;(_Saved_offset), _Old_size);
#endif // _ITERATOR_DEBUG_LEVEL == 2
            _STD rotate(begin() + _Saved_offset, begin() + static_cast&lt;difference_type&gt;(_Old_size), end());
        }

        return begin() + _Saved_offset;
    }

#if _HAS_CXX23
    template &lt;_Container_compatible_range&lt;bool&gt; _Rng&gt;
    constexpr iterator insert_range(const_iterator _Where, _Rng&amp;&amp; _Range) {
        const difference_type _Old_off = _Where - begin();

        if constexpr (_RANGES forward_range&lt;_Rng&gt; || _RANGES sized_range&lt;_Rng&gt;) {
            const auto _Length = _To_unsigned_like(_RANGES distance(_Range));
            const auto _Count  = _Convert_size&lt;size_type&gt;(_Length);
            const auto _Off    = static_cast&lt;difference_type&gt;(_Insert_x(_Where, _Count));
            _Copy_n_unchecked4(_RANGES _Ubegin(_Range), _Count, begin() + _Off);
        } else {
            auto _UFirst         = _RANGES _Ubegin(_Range);
            const auto _ULast    = _RANGES _Uend(_Range);
            const auto _Old_size = this-&gt;_Mysize;
            for (; _UFirst != _ULast; ++_UFirst) {
                emplace_back(*_UFirst);
            }
#if _ITERATOR_DEBUG_LEVEL == 2
            _Orphan_range(static_cast&lt;size_type&gt;(_Old_off), _Old_size);
#endif // _ITERATOR_DEBUG_LEVEL == 2
            _STD rotate(begin() + _Old_off, begin() + static_cast&lt;difference_type&gt;(_Old_size), end());
        }

        return begin() + _Old_off;
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 iterator erase(const_iterator _Where_arg) noexcept /* strengthened */ {
        iterator _Where      = _Make_iter(_Where_arg);
        difference_type _Off = _Where - begin();

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(end() &gt; _Where, "vector&lt;bool&gt; erase iterator outside range");
#endif

        _STD copy(_Next_iter(_Where), end(), _Where);

#if _ITERATOR_DEBUG_LEVEL == 2
        _Orphan_range(static_cast&lt;size_type&gt;(_Off), this-&gt;_Mysize);
#endif

        _Trim(this-&gt;_Mysize - 1);
        return begin() + _Off;
    }

    _CONSTEXPR20 iterator erase(const_iterator _First_arg, const_iterator _Last_arg) noexcept
    /* strengthened */ {
        iterator _First      = _Make_iter(_First_arg);
        iterator _Last       = _Make_iter(_Last_arg);
        difference_type _Off = _First - begin();

        if (_First != _Last) { // worth doing, copy down over hole
#if _ITERATOR_DEBUG_LEVEL == 2
            _STL_VERIFY(_Last &gt;= _First &amp;&amp; end() &gt;= _Last, "vector&lt;bool&gt; erase iterator outside range");
#endif

            iterator _Next      = _STD copy(_Last, end(), _First);
            const auto _Newsize = static_cast&lt;size_type&gt;(_Next - begin());

#if _ITERATOR_DEBUG_LEVEL == 2
            _Orphan_range(_Newsize, this-&gt;_Mysize);
#endif

            _Trim(_Newsize);
        }
        return begin() + _Off;
    }

    _CONSTEXPR20 void clear() noexcept {
        this-&gt;_Orphan_all();
        this-&gt;_Myvec.clear();
        this-&gt;_Mysize = 0;
    }

    _CONSTEXPR20 void flip() noexcept { // toggle all elements
        for (auto&amp; _Elem : this-&gt;_Myvec) {
            _Elem = ~_Elem;
        }

        _Trim(this-&gt;_Mysize);
    }

    _CONSTEXPR20 void swap(vector&amp; _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            this-&gt;_Swap_proxy_and_iterators(_Right);
            this-&gt;_Myvec.swap(_Right._Myvec);
            _STD swap(this-&gt;_Mysize, _Right._Mysize);
        }
    }

    static _CONSTEXPR20 void swap(reference _Left, reference _Right) noexcept {
        bool _Val = _Left; // NOT _STD swap
        _Left     = _Right;
        _Right    = _Val;
    }

    friend hash&lt;vector&lt;bool, _Alloc&gt;&gt;;

    _CONSTEXPR20 iterator _Insert_n(const_iterator _Where, size_type _Count, const bool&amp; _Val) {
        size_type _Off     = _Insert_x(_Where, _Count);
        const auto _Result = begin() + static_cast&lt;difference_type&gt;(_Off);
        _STD fill_n(_Result, _Count, _Val);
        return _Result;
    }

    _CONSTEXPR20 size_type _Insert_x(const_iterator _Where, size_type _Count) {
        const difference_type _Off = _Where - begin();

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(end() &gt;= _Where, "vector&lt;bool&gt; insert iterator outside range");
        const bool _Realloc = capacity() - size() &lt; _Count;
#endif // _ITERATOR_DEBUG_LEVEL == 2

        if (_Count != 0) {
            if (max_size() - size() &lt; _Count) {
                _Xlen(); // result too long
            }

#if _ITERATOR_DEBUG_LEVEL == 2
            _Orphan_range(static_cast&lt;size_type&gt;(_Realloc ? 0 : _Off), this-&gt;_Mysize);
#endif // _ITERATOR_DEBUG_LEVEL == 2
            this-&gt;_Myvec.resize(this-&gt;_Nw(size() + _Count), 0);
            if (empty()) {
                this-&gt;_Mysize += _Count;
            } else { // make room and copy down suffix
                iterator _Oldend = end();
                this-&gt;_Mysize += _Count;
                _STD copy_backward(begin() + _Off, _Oldend, end());
            }
        }

        return static_cast&lt;size_type&gt;(_Off);
    }

#if _ITERATOR_DEBUG_LEVEL == 2
    _CONSTEXPR20 void _Orphan_range_unlocked(size_type _Offlo, size_type _Offhi) const {
        const auto _Base = this-&gt;_Myvec.data();

        _Iterator_base12** _Pnext = &amp;this-&gt;_Myproxy-&gt;_Myfirstiter;
        while (*_Pnext) { // test offset from beginning of vector
            const auto&amp; _Pnextiter = static_cast&lt;typename const_iterator::_Mybase&amp;&gt;(**_Pnext);
            const auto _Temp       = *_Pnext;
            if (!_Pnextiter._Myptr) { // orphan the iterator
                _Temp-&gt;_Myproxy = nullptr;
                *_Pnext         = _Temp-&gt;_Mynextiter;
                continue;
            }
            const auto _Off =
                static_cast&lt;size_type&gt;(const_iterator::_VBITS_DIFF * (_Pnextiter._Myptr - _Base)) + _Pnextiter._Myoff;
            if (_Off &lt; _Offlo || _Offhi &lt; _Off) {
                _Pnext = &amp;_Temp-&gt;_Mynextiter;
            } else { // orphan the iterator
                _Temp-&gt;_Myproxy = nullptr;
                *_Pnext         = _Temp-&gt;_Mynextiter;
            }
        }
    }

    void _Orphan_range_locked(size_type _Offlo, size_type _Offhi) const {
        _Lockit _Lock(_LOCK_DEBUG);
        _Orphan_range_unlocked(_Offlo, _Offhi);
    }

    _CONSTEXPR20 void _Orphan_range(size_type _Offlo, size_type _Offhi) const {
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            _Orphan_range_unlocked(_Offlo, _Offhi);
        } else
#endif // _HAS_CXX20
        {
            _Orphan_range_locked(_Offlo, _Offhi);
        }
    }
#endif // _ITERATOR_DEBUG_LEVEL == 2

    _CONSTEXPR20 void _Trim(size_type _Size) {
        if (max_size() &lt; _Size) {
            _Xlen(); // result too long
        }

        const size_type _Words = this-&gt;_Nw(_Size);
        if (_Words &lt; this-&gt;_Myvec.size()) {
            this-&gt;_Myvec.erase(this-&gt;_Myvec.begin() + static_cast&lt;difference_type&gt;(_Words), this-&gt;_Myvec.end());
        }

        this-&gt;_Mysize = _Size;
        _Size %= _VBITS;
        if (0 &lt; _Size) {
            this-&gt;_Myvec[_Words - 1] &amp;= (static_cast&lt;_Vbase&gt;(1) &lt;&lt; _Size) - 1;
        }
    }

    [[noreturn]] static void _Xlen() {
        _Xlength_error("vector&lt;bool&gt; too long");
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid vector&lt;bool&gt; subscript");
    }
};

template &lt;class _Alloc&gt;
struct hash&lt;vector&lt;bool, _Alloc&gt;&gt; {
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = vector&lt;bool, _Alloc&gt;;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS   = size_t;

    _NODISCARD _STATIC_CALL_OPERATOR size_t operator()(
        const vector&lt;bool, _Alloc&gt;&amp; _Keyval) _CONST_CALL_OPERATOR noexcept {
        return _Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size());
    }
};

#if _HAS_CXX17
namespace pmr {
    _EXPORT_STD template &lt;class _Ty&gt;
    using vector = _STD vector&lt;_Ty, polymorphic_allocator&lt;_Ty&gt;&gt;;
} // namespace pmr
#endif // _HAS_CXX17

#if _HAS_CXX23
// Per LWG-3997, `_CharT` in library-provided `formatter` specializations is
// constrained to character types supported by `format`.
template &lt;class _Ty, _Format_supported_charT _CharT&gt;
    requires _Is_specialization_v&lt;_Ty, _Vb_reference&gt;
struct formatter&lt;_Ty, _CharT&gt; {
private:
    formatter&lt;bool, _CharT&gt; _Underlying;

public:
    template &lt;class _ParseContext&gt;
    constexpr _ParseContext::iterator parse(_ParseContext&amp; _Ctx) {
        return _Underlying.parse(_Ctx);
    }

    template &lt;class _FormatContext&gt;
    _FormatContext::iterator format(const _Ty&amp; _Ref, _FormatContext&amp; _Ctx) const {
        return _Underlying.format(_Ref, _Ctx);
    }
};

template &lt;class _Ty&gt;
    requires _Is_specialization_v&lt;_Ty, _Vb_reference&gt;
constexpr bool enable_nonlocking_formatter_optimization&lt;_Ty&gt; = true;
#endif // _HAS_CXX23

template &lt;class _Alloc, bool _RequiresMutable&gt;
constexpr bool _Is_vb_iterator&lt;_Vb_iterator&lt;_Alloc&gt;, _RequiresMutable&gt; = true;

template &lt;class _Alloc&gt;
constexpr bool _Is_vb_iterator&lt;_Vb_const_iterator&lt;_Alloc&gt;, false&gt; = true;

template &lt;class _VbIt&gt;
_CONSTEXPR20 void _Fill_vbool(_VbIt _First, const _VbIt _Last, const bool _Val) noexcept {
    // Set [_First, _Last) to _Val
    if (_First == _Last) {
        return;
    }

    _Vbase* _VbFirst      = const_cast&lt;_Vbase*&gt;(_First._Myptr);
    _Vbase* const _VbLast = const_cast&lt;_Vbase*&gt;(_Last._Myptr);

    const auto _FirstSourceMask = static_cast&lt;_Vbase&gt;(-1) &lt;&lt; _First._Myoff;
    const auto _FirstDestMask   = ~_FirstSourceMask;
    const auto _FillVal         = static_cast&lt;_Vbase&gt;(_Val ? -1 : 0);

    if (_VbFirst == _VbLast) {
        // We already excluded _First == _Last, so here _Last._Myoff &gt; 0 and the shift is safe
        const auto _LastSourceMask = static_cast&lt;_Vbase&gt;(-1) &gt;&gt; (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        const auto _SourceMask     = _FirstSourceMask &amp; _LastSourceMask;
        const auto _DestMask       = _FirstDestMask | _LastDestMask;
        *_VbFirst                  = (*_VbFirst &amp; _DestMask) | (_FillVal &amp; _SourceMask);
        return;
    }

    *_VbFirst = (*_VbFirst &amp; _FirstDestMask) | (_FillVal &amp; _FirstSourceMask);
    ++_VbFirst;

#if _HAS_CXX20
    if (_STD is_constant_evaluated()) {
        for (; _VbFirst != _VbLast; ++_VbFirst) {
            *_VbFirst = _FillVal;
        }
    } else
#endif // _HAS_CXX20
    {
        const auto _VbFirst_ch = reinterpret_cast&lt;const char*&gt;(_VbFirst);
        const auto _VbLast_ch  = reinterpret_cast&lt;const char*&gt;(_VbLast);
        const auto _Count_ch   = static_cast&lt;size_t&gt;(_VbLast_ch - _VbFirst_ch);
        const auto _ValChar    = static_cast&lt;unsigned char&gt;(_Val ? -1 : 0);
        _CSTD memset(_VbFirst, _ValChar, _Count_ch);
        _VbFirst = _VbLast;
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast&lt;_Vbase&gt;(-1) &gt;&gt; (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        *_VbFirst                  = (*_VbFirst &amp; _LastDestMask) | (_FillVal &amp; _LastSourceMask);
    }
}

template &lt;class _VbIt&gt;
_NODISCARD _CONSTEXPR20 _VbIt _Find_vbool(_VbIt _First, const _VbIt _Last, const bool _Val) noexcept {
    // Find _Val in [_First, _Last)
    if (_First == _Last) {
        return _First;
    }

    const _Vbase* _VbFirst      = _First._Myptr;
    const _Vbase* const _VbLast = _Last._Myptr;

    const auto _FirstSourceMask = static_cast&lt;_Vbase&gt;(-1) &lt;&lt; _First._Myoff;

    if (_VbFirst == _VbLast) {
        // We already excluded _First == _Last, so here _Last._Myoff &gt; 0 and the shift is safe
        const auto _LastSourceMask = static_cast&lt;_Vbase&gt;(-1) &gt;&gt; (_VBITS - _Last._Myoff);
        const auto _SourceMask     = _FirstSourceMask &amp; _LastSourceMask;
        const auto _SelectVal      = (_Val ? *_VbFirst : ~*_VbFirst) &amp; _SourceMask;
        const auto _Count          = _Countr_zero(_SelectVal);
        return _Count == _VBITS ? _Last : _First + static_cast&lt;ptrdiff_t&gt;(_Count - _First._Myoff);
    }

    const auto _FirstVal   = (_Val ? *_VbFirst : ~*_VbFirst) &amp; _FirstSourceMask;
    const auto _FirstCount = _Countr_zero(_FirstVal);
    if (_FirstCount != _VBITS) {
        return _First + static_cast&lt;ptrdiff_t&gt;(_FirstCount - _First._Myoff);
    }
    ++_VbFirst;

    _Iter_diff_t&lt;_VbIt&gt; _TotalCount = static_cast&lt;ptrdiff_t&gt;(_VBITS - _First._Myoff);
    for (; _VbFirst != _VbLast; ++_VbFirst, _TotalCount += _VBITS) {
        const auto _SelectVal = _Val ? *_VbFirst : ~*_VbFirst;
        const auto _Count     = _Countr_zero(_SelectVal);
        if (_Count != _VBITS) {
            return _First + (_TotalCount + _Count);
        }
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast&lt;_Vbase&gt;(-1) &gt;&gt; (_VBITS - _Last._Myoff);
        const auto _LastVal        = (_Val ? *_VbFirst : ~*_VbFirst) &amp; _LastSourceMask;
        const auto _Count          = _Countr_zero(_LastVal);
        if (_Count != _VBITS) {
            return _First + (_TotalCount + _Count);
        }
    }

    return _Last;
}

template &lt;class _VbIt&gt;
_NODISCARD _CONSTEXPR20 _Iter_diff_t&lt;_VbIt&gt; _Count_vbool(_VbIt _First, const _VbIt _Last, const bool _Val) noexcept {
    if (_First == _Last) {
        return 0;
    }

    const _Vbase* _VbFirst      = _First._Myptr;
    const _Vbase* const _VbLast = _Last._Myptr;

    const auto _FirstSourceMask = static_cast&lt;_Vbase&gt;(-1) &lt;&lt; _First._Myoff;

    if (_VbFirst == _VbLast) {
        // We already excluded _First == _Last, so here _Last._Myoff &gt; 0 and the shift is safe
        const auto _LastSourceMask = static_cast&lt;_Vbase&gt;(-1) &gt;&gt; (_VBITS - _Last._Myoff);
        const auto _SourceMask     = _FirstSourceMask &amp; _LastSourceMask;
        const auto _SelectVal      = (_Val ? *_VbFirst : ~*_VbFirst) &amp; _SourceMask;
        return _Popcount(_SelectVal);
    }

    return _Select_popcount_impl&lt;_Vbase&gt;(
        [_Last, _Val, _VbFirst, _VbLast, _FirstSourceMask](auto _Popcount_impl) mutable noexcept {
            const auto _FirstVal       = (_Val ? *_VbFirst : ~*_VbFirst) &amp; _FirstSourceMask;
            _Iter_diff_t&lt;_VbIt&gt; _Count = _Popcount_impl(_FirstVal);
            ++_VbFirst;

            for (; _VbFirst != _VbLast; ++_VbFirst) {
                const auto _SelectVal = _Val ? *_VbFirst : ~*_VbFirst;
                _Count += _Popcount_impl(_SelectVal);
            }

            if (_Last._Myoff != 0) {
                const auto _LastSourceMask = static_cast&lt;_Vbase&gt;(-1) &gt;&gt; (_VBITS - _Last._Myoff);
                const auto _LastVal        = (_Val ? *_VbFirst : ~*_VbFirst) &amp; _LastSourceMask;
                _Count += _Popcount_impl(_LastVal);
            }

            return _Count;
        });
}

template &lt;class _VbIt, class _OutIt&gt;
_CONSTEXPR20 _OutIt _Copy_vbool(_VbIt _First, _VbIt _Last, _OutIt _Dest) {
    // copy [_First, _Last) to [_Dest, ...)
    if (_First == _Last) {
        return _Dest;
    }

    auto _VbFirst       = _First._Myptr;
    const auto _VbLast  = _Last._Myptr;
    auto _VbDest        = const_cast&lt;_Vbase*&gt;(_Dest._Myptr);
    const auto _DestEnd = _Dest + (_Last - _First);

    const auto _FirstSourceMask = static_cast&lt;_Vbase&gt;(-1) &lt;&lt; _First._Myoff;
    const auto _FirstDestMask   = _Dest._Myoff == 0 ? 0 : (static_cast&lt;_Vbase&gt;(-1) &gt;&gt; (_VBITS - _Dest._Myoff));
    const auto _LastSourceMask  = static_cast&lt;_Vbase&gt;(-1) &gt;&gt; (_VBITS - _Last._Myoff);
    const auto _LastDestMask    = static_cast&lt;_Vbase&gt;(-1) &lt;&lt; _DestEnd._Myoff;

    const bool _IsSingleBlockSource = _VbFirst == _VbLast;
    const bool _IsSingleBlockDest   = _VbDest == _DestEnd._Myptr - (_DestEnd._Myoff == 0 ? 1 : 0);
    const bool _IsRightShift        = _Dest._Myoff &lt; _First._Myoff;
    if (_IsSingleBlockSource) {
        // We already excluded _First == _Last, so here _Last._Myoff &gt; 0 and the shift is safe
        const auto _SourceMask  = _FirstSourceMask &amp; _LastSourceMask;
        const auto _SourceShift = _IsRightShift ? _First._Myoff - _Dest._Myoff : _Dest._Myoff - _First._Myoff;
        const auto _SourceVal   = _IsRightShift ? (*_VbFirst &amp; _SourceMask) &gt;&gt; _SourceShift //
                                                : (*_VbFirst &amp; _SourceMask) &lt;&lt; _SourceShift;
        if (_IsSingleBlockDest) {
            const auto _DestMask = _FirstDestMask | (_DestEnd._Myoff == 0 ? 0 : _LastDestMask);
            *_VbDest             = (*_VbDest &amp; _DestMask) | _SourceVal;
        } else {
            *_VbDest = (*_VbDest &amp; _FirstDestMask) | _SourceVal;
            ++_VbDest;

            const auto _LastShift     = _Last._Myoff - _DestEnd._Myoff;
            const auto _LastSourceVal = (*_VbFirst &amp; _SourceMask) &gt;&gt; _LastShift;
            *_VbDest                  = (*_VbDest &amp; _LastDestMask) | _LastSourceVal;
        }

        return _DestEnd;
    } else if (_IsSingleBlockDest) {
        const auto _SourceShift = _IsRightShift ? _First._Myoff - _Dest._Myoff : _Dest._Myoff - _First._Myoff;
        const auto _SourceVal   = _IsRightShift ? (*_VbFirst &amp; _FirstSourceMask) &gt;&gt; _SourceShift //
                                                : (*_VbFirst &amp; _FirstSourceMask) &lt;&lt; _SourceShift;

        const auto _DestMask = _FirstDestMask | (_DestEnd._Myoff == 0 ? 0 : _LastDestMask);
        if (_Last._Myoff != 0) {
            const auto _LastShift     = _DestEnd._Myoff - _Last._Myoff;
            const auto _LastSourceVal = (*_VbLast &amp; _LastSourceMask) &lt;&lt; _LastShift;
            *_VbDest                  = (*_VbDest &amp; _DestMask) | _SourceVal | _LastSourceVal;
        } else {
            *_VbDest = (*_VbDest &amp; _DestMask) | _SourceVal;
        }

        return _DestEnd;
    }

#if _HAS_CXX20
    if (!_STD is_constant_evaluated())
#endif
    {
        // If _First and _Dest have matching char alignment, use memmove
        const auto _UnalignedFirstBits = _First._Myoff &amp; _Vbase{7};
        const auto _UnalignedDestBits  = _Dest._Myoff &amp; _Vbase{7};
        if (_UnalignedFirstBits == _UnalignedDestBits) {
            const auto _UnalignedLastBits = _Last._Myoff &amp; _Vbase{7};

            auto _VbFirst_ch      = reinterpret_cast&lt;const char*&gt;(_VbFirst) + (_First._Myoff - _UnalignedFirstBits) / 8;
            const auto _VbLast_ch = reinterpret_cast&lt;const char*&gt;(_VbLast) + (_Last._Myoff - _UnalignedLastBits) / 8;
            auto _VbDest_ch       = reinterpret_cast&lt;char*&gt;(_VbDest) + (_Dest._Myoff - _UnalignedDestBits) / 8;

            // Copy bits until the next char alignment
            if (_UnalignedFirstBits != 0) {
                const auto _SourceBitMask = static_cast&lt;char&gt;(UCHAR_MAX &lt;&lt; _UnalignedFirstBits);
                const auto _DestBitMask   = static_cast&lt;char&gt;(UCHAR_MAX &gt;&gt; (8 - _UnalignedFirstBits));
                *_VbDest_ch               = (*_VbDest_ch &amp; _DestBitMask) | (*_VbFirst_ch &amp; _SourceBitMask);
                ++_VbFirst_ch;
                ++_VbDest_ch;
            }

            _VbDest_ch = _Copy_unchecked(_VbFirst_ch, _VbLast_ch, _VbDest_ch);

            // Copy remaining last bits
            if (_UnalignedLastBits != 0) {
                const auto _SourceBitMask = static_cast&lt;char&gt;(UCHAR_MAX &gt;&gt; (8 - _UnalignedLastBits));
                const auto _DestBitMask   = static_cast&lt;char&gt;(UCHAR_MAX &lt;&lt; _UnalignedLastBits);
                *_VbDest_ch               = (*_VbDest_ch &amp; _DestBitMask) | (*_VbLast_ch &amp; _SourceBitMask);
            }

            return _DestEnd;
        }
    }

    // Unaligned _VbFirst and _VbLast require a two step copy with carry
    if (_IsRightShift) {
        const auto _SourceShift = _First._Myoff - _Dest._Myoff;
        const auto _CarryShift  = _VBITS - _SourceShift;
        const auto _CarryMask   = static_cast&lt;_Vbase&gt;(-1) &gt;&gt; _SourceShift;
        const auto _DestMask    = ~_CarryMask;

        const auto _FirstSourceVal = (*_VbFirst &amp; _FirstSourceMask) &gt;&gt; _SourceShift;
        *_VbDest                   = (*_VbDest &amp; _FirstDestMask) | _FirstSourceVal;

        ++_VbFirst;
        for (; _VbFirst != _VbLast; ++_VbFirst) {
            const auto _CarryVal = *_VbFirst &lt;&lt; _CarryShift;
            *_VbDest             = (*_VbDest &amp; _CarryMask) | _CarryVal;

            ++_VbDest;
            const auto _SourceVal = *_VbFirst &gt;&gt; _SourceShift;
            *_VbDest              = (*_VbDest &amp; _DestMask) | _SourceVal;
        }

        if (_Last._Myoff != 0) {
            const auto _CarryVal = (*_VbFirst &amp; _LastSourceMask) &lt;&lt; _CarryShift;
            if (_Last._Myoff &gt;= _SourceShift) {
                *_VbDest = (*_VbDest &amp; _CarryMask) | _CarryVal;

                // We have more bits remaining than the final block has left
                if (_Last._Myoff != _SourceShift) {
                    ++_VbDest;
                    const auto _SourceVal = (*_VbFirst &amp; _LastSourceMask) &gt;&gt; _SourceShift;
                    *_VbDest              = (*_VbDest &amp; _LastDestMask) | _SourceVal;
                }
            } else {
                // There are not enough bits to fill the final block so we need to mask both ends
                const auto _FinalMask = _CarryMask | _LastDestMask;
                *_VbDest              = (*_VbDest &amp; _FinalMask) | _CarryVal;
            }
        }
    } else {
        const auto _SourceShift = _Dest._Myoff - _First._Myoff;
        const auto _CarryShift  = _VBITS - _SourceShift;

        const auto _FirstSourceVal = (*_VbFirst &amp; _FirstSourceMask) &lt;&lt; _SourceShift;
        *_VbDest                   = (*_VbDest &amp; _FirstDestMask) | _FirstSourceVal;
        auto _CarryVal             = *_VbFirst &gt;&gt; _CarryShift;

        ++_VbFirst;
        ++_VbDest;
        for (; _VbFirst != _VbLast; ++_VbFirst, ++_VbDest) {
            const auto _SourceVal = *_VbFirst &lt;&lt; _SourceShift;
            *_VbDest              = _CarryVal | _SourceVal;
            _CarryVal             = *_VbFirst &gt;&gt; _CarryShift;
        }

        if (_Last._Myoff &gt;= _CarryShift) {
            const auto _SourceVal = *_VbFirst &lt;&lt; _SourceShift;
            *_VbDest              = _CarryVal | _SourceVal;
            _CarryVal             = *_VbFirst &gt;&gt; _CarryShift;

            // We have more bits remaining than the final block has left
            if (_Last._Myoff != _CarryShift) {
                ++_VbDest;
                const auto _LastCarryMask = ~_LastDestMask;
                *_VbDest                  = (*_VbDest &amp; _LastDestMask) | (_CarryVal &amp; _LastCarryMask);
            }
        } else if (_Last._Myoff != 0) {
            // There are not enough bits to fill the final block so we need to mask both ends
            const auto _LastSourceVal = (*_VbFirst &amp; _LastSourceMask) &lt;&lt; _SourceShift;
            *_VbDest                  = (*_VbDest &amp; _LastDestMask) | _CarryVal | _LastSourceVal;
        } else {
            // No new bits, just copy the carry
            *_VbDest = (*_VbDest &amp; _LastDestMask) | _CarryVal;
        }
    }

    return _DestEnd;
}

#undef _ASAN_VECTOR_MODIFY
#undef _ASAN_VECTOR_REMOVE
#undef _ASAN_VECTOR_CREATE
#undef _ASAN_VECTOR_CREATE_GUARD
#undef _ASAN_VECTOR_EXTEND_GUARD
#undef _ASAN_VECTOR_RELEASE_GUARD
#undef _INSERT_VECTOR_ANNOTATION
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _VECTOR_</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>