<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>utility</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// utility standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _UTILITY_
#define _UTILITY_
#include &lt;yvals_core.h&gt;
#if _STL_COMPILER_PREPROCESSOR
#include &lt;initializer_list&gt;
#include &lt;type_traits&gt;

#if _HAS_CXX20
#include &lt;compare&gt;
#include &lt;concepts&gt;
#endif // _HAS_CXX20

#if _HAS_CXX23
#include &lt;cstdlib&gt;
#endif // _HAS_CXX23

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// TRANSITION, non-_Ugly attribute tokens
#pragma push_macro("msvc")
#pragma push_macro("intrinsic")
#pragma push_macro("known_semantics")
#pragma push_macro("lifetimebound")
#undef msvc
#undef intrinsic
#undef known_semantics
#undef lifetimebound

_STD_BEGIN
_EXPORT_STD template &lt;class _Ty, _Ty... _Vals&gt;
struct integer_sequence { // sequence of integer parameters
    static_assert(is_integral_v&lt;_Ty&gt;, "integer_sequence&lt;T, I...&gt; requires T to be an integral type.");

    using value_type = _Ty;

    _NODISCARD static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

_EXPORT_STD template &lt;class _Ty, _Ty _Size&gt;
using make_integer_sequence = __make_integer_seq&lt;integer_sequence, _Ty, _Size&gt;;

_EXPORT_STD template &lt;size_t... _Vals&gt;
using index_sequence = integer_sequence&lt;size_t, _Vals...&gt;;

_EXPORT_STD template &lt;size_t _Size&gt;
using make_index_sequence = make_integer_sequence&lt;size_t, _Size&gt;;

_EXPORT_STD template &lt;class... _Types&gt;
using index_sequence_for = make_index_sequence&lt;sizeof...(_Types)&gt;;

_EXPORT_STD template &lt;class _Ty, class _Pr&gt;
_NODISCARD constexpr const _Ty&amp;(max) (const _Ty&amp; _Left _MSVC_LIFETIMEBOUND, const _Ty&amp; _Right _MSVC_LIFETIMEBOUND,
    _Pr _Pred) noexcept(noexcept(_Pred(_Left, _Right))) /* strengthened */ {
    // return larger of _Left and _Right
    return _Pred(_Left, _Right) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) // (syntax error in SAL annotation, occurs when _Ty is not an integral type)
_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD _Post_equal_to_(_Left &lt; _Right ? _Right : _Left) constexpr const _Ty&amp; //
    (max) (const _Ty&amp; _Left _MSVC_LIFETIMEBOUND, const _Ty&amp; _Right _MSVC_LIFETIMEBOUND)
<span style = "background-color:#dfd">        noexcept(noexcept(_Left &lt; _Right)) /* strengthened */ {</span>
    // return larger of _Left and _Right
<span style = "background-color:#dfd">    return _Left &lt; _Right ? _Right : _Left;
}</span>
#pragma warning(pop)

_EXPORT_STD template &lt;class _Ty, class _Pr&gt;
_NODISCARD constexpr _Ty(max)(initializer_list&lt;_Ty&gt;, _Pr); // implemented in &lt;algorithm&gt;

_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty(max)(initializer_list&lt;_Ty&gt;); // implemented in &lt;algorithm&gt;

_EXPORT_STD template &lt;class _Ty, class _Pr&gt;
_NODISCARD constexpr const _Ty&amp;(min) (const _Ty&amp; _Left _MSVC_LIFETIMEBOUND, const _Ty&amp; _Right _MSVC_LIFETIMEBOUND,
    _Pr _Pred) noexcept(noexcept(_Pred(_Right, _Left))) /* strengthened */ {
    // return smaller of _Left and _Right
    return _Pred(_Right, _Left) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) // (syntax error in SAL annotation, occurs when _Ty is not an integral type)
_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD _Post_equal_to_(_Right &lt; _Left ? _Right : _Left) constexpr const _Ty&amp; //
    (min) (const _Ty&amp; _Left _MSVC_LIFETIMEBOUND, const _Ty&amp; _Right _MSVC_LIFETIMEBOUND)
<span style = "background-color:#dfd">        noexcept(noexcept(_Right &lt; _Left)) /* strengthened */ {</span>
    // return smaller of _Left and _Right
<span style = "background-color:#dfd">    return _Right &lt; _Left ? _Right : _Left;
}</span>
#pragma warning(pop)

_EXPORT_STD template &lt;class _Ty, class _Pr&gt;
_NODISCARD constexpr _Ty(min)(initializer_list&lt;_Ty&gt;, _Pr); // implemented in &lt;algorithm&gt;

_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty(min)(initializer_list&lt;_Ty&gt;); // implemented in &lt;algorithm&gt;

_EXPORT_STD template &lt;class _Ty, size_t _Size, enable_if_t&lt;_Is_swappable&lt;_Ty&gt;::value, int&gt; /* = 0 */&gt;
_CONSTEXPR20 void swap(_Ty (&amp;_Left)[_Size], _Ty (&amp;_Right)[_Size]) noexcept(_Is_nothrow_swappable&lt;_Ty&gt;::value) {
    if (&amp;_Left == &amp;_Right) {
        return; // Handle self-swap as a no-op; see LWG-4165
    }

    if constexpr (_Is_trivially_swappable_v&lt;_Ty&gt;) {
        if (!_STD _Is_constant_evaluated()) {
            _STD _Swap_trivial_arrays(_Left, _Right);
            return;
        }
    }

    _Ty* _First1 = _Left;
    _Ty* _Last1  = _First1 + _Size;
    _Ty* _First2 = _Right;
    for (; _First1 != _Last1; ++_First1, ++_First2) {
        swap(*_First1, *_First2); // intentional ADL
    }
}

#if _HAS_CXX17
_EXPORT_STD template &lt;class _Ty, enable_if_t&lt;is_move_constructible_v&lt;_Ty&gt; &amp;&amp; is_move_assignable_v&lt;_Ty&gt;, int&gt; /* = 0 */&gt;
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
template &lt;class _Ty, int _Enabled /* = 0 */&gt;
#endif // ^^^ !_HAS_CXX17 ^^^
_CONSTEXPR20 void swap(_Ty&amp; _Left, _Ty&amp; _Right)
<span style = "background-color:#fdd">    noexcept(is_nothrow_move_constructible_v&lt;_Ty&gt; &amp;&amp; is_nothrow_move_assignable_v&lt;_Ty&gt;) {
    _Ty _Tmp = _STD move(_Left);
    _Left    = _STD move(_Right);
    _Right   = _STD move(_Tmp);
}</span>

_EXPORT_STD struct piecewise_construct_t { // tag type for pair tuple arguments
    explicit piecewise_construct_t() = default;
};

_EXPORT_STD _INLINE_VAR constexpr piecewise_construct_t piecewise_construct{};

struct _Ignore { // struct that ignores assignments
    template &lt;class _Ty&gt;
    constexpr const _Ignore&amp; operator=(const _Ty&amp;) const noexcept {
        // do nothing
        return *this;
    }
};

_EXPORT_STD _INLINE_VAR constexpr _Ignore ignore{};

_EXPORT_STD template &lt;class... _Types&gt;
class tuple;

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
struct pair;

_EXPORT_STD template &lt;class _Ty, size_t _Size&gt;
class array;

_EXPORT_STD template &lt;class _Tuple&gt;
struct tuple_size;

_EXPORT_STD template &lt;class _Ty&gt;
constexpr size_t tuple_size_v = tuple_size&lt;_Ty&gt;::value;

_EXPORT_STD template &lt;size_t _Index, class _Tuple&gt;
struct tuple_element;

_EXPORT_STD template &lt;size_t _Index, class _Tuple&gt;
using tuple_element_t = typename tuple_element&lt;_Index, _Tuple&gt;::type;

template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr auto&amp;&amp; _Tuple_get(tuple&lt;_Types...&gt;&amp;&amp; _Tuple) noexcept;

_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp; get(tuple&lt;_Types...&gt;&amp; _Tuple) noexcept;

_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr const tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp; get(const tuple&lt;_Types...&gt;&amp; _Tuple) noexcept;

_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp;&amp; get(tuple&lt;_Types...&gt;&amp;&amp; _Tuple) noexcept;

_EXPORT_STD template &lt;size_t _Index, class... _Types&gt;
_NODISCARD constexpr const tuple_element_t&lt;_Index, tuple&lt;_Types...&gt;&gt;&amp;&amp; get(const tuple&lt;_Types...&gt;&amp;&amp; _Tuple) noexcept;

_EXPORT_STD template &lt;size_t _Idx, class _Ty, size_t _Size&gt;
_NODISCARD constexpr _Ty&amp; get(array&lt;_Ty, _Size&gt;&amp; _Arr) noexcept;

_EXPORT_STD template &lt;size_t _Idx, class _Ty, size_t _Size&gt;
_NODISCARD constexpr const _Ty&amp; get(const array&lt;_Ty, _Size&gt;&amp; _Arr) noexcept;

_EXPORT_STD template &lt;size_t _Idx, class _Ty, size_t _Size&gt;
_NODISCARD constexpr _Ty&amp;&amp; get(array&lt;_Ty, _Size&gt;&amp;&amp; _Arr) noexcept;

_EXPORT_STD template &lt;size_t _Idx, class _Ty, size_t _Size&gt;
_NODISCARD constexpr const _Ty&amp;&amp; get(const array&lt;_Ty, _Size&gt;&amp;&amp; _Arr) noexcept;

#if _HAS_CXX20
template &lt;class _Ty1, class _Ty2&gt;
concept _Different_from = !same_as&lt;remove_cvref_t&lt;_Ty1&gt;, remove_cvref_t&lt;_Ty2&gt;&gt;;

template &lt;class&gt;
constexpr bool _Is_subrange_v = false;

#if _HAS_CXX23
template &lt;class&gt;
constexpr bool _Tuple_like_non_subrange_impl = false;

template &lt;class... _Types&gt;
constexpr bool _Tuple_like_non_subrange_impl&lt;tuple&lt;_Types...&gt;&gt; = true;

template &lt;class _Ty1, class _Ty2&gt;
constexpr bool _Tuple_like_non_subrange_impl&lt;pair&lt;_Ty1, _Ty2&gt;&gt; = true;

template &lt;class _Ty, size_t _Size&gt;
constexpr bool _Tuple_like_non_subrange_impl&lt;array&lt;_Ty, _Size&gt;&gt; = true;

template &lt;class _Ty&gt;
concept _Tuple_like_non_subrange = _Tuple_like_non_subrange_impl&lt;remove_cvref_t&lt;_Ty&gt;&gt;;

template &lt;class _Ty&gt;
concept _Tuple_like = _Tuple_like_non_subrange&lt;_Ty&gt; || _Is_subrange_v&lt;remove_cvref_t&lt;_Ty&gt;&gt;;

template &lt;class _Ty&gt;
concept _Pair_like_non_subrange = _Tuple_like_non_subrange&lt;_Ty&gt; &amp;&amp; tuple_size_v&lt;remove_cvref_t&lt;_Ty&gt;&gt; == 2;

#ifdef __EDG__ // TRANSITION, VSO-1900279
template &lt;class _PairLike, class _Ty1, class _Ty2&gt;
concept _Can_construct_from_pair_like =
    _Pair_like_non_subrange&lt;_PairLike&gt; &amp;&amp; is_constructible_v&lt;_Ty1, decltype(_STD get&lt;0&gt;(_STD declval&lt;_PairLike&gt;()))&gt;
    &amp;&amp; is_constructible_v&lt;_Ty2, decltype(_STD get&lt;1&gt;(_STD declval&lt;_PairLike&gt;()))&gt;;
#endif // ^^^ workaround ^^^
#endif // _HAS_CXX23
#endif // _HAS_CXX20

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
struct pair { // store a pair of values
    using first_type  = _Ty1;
    using second_type = _Ty2;

    template &lt;class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t&lt;conjunction_v&lt;is_default_constructible&lt;_Uty1&gt;, is_default_constructible&lt;_Uty2&gt;&gt;, int&gt; = 0&gt;
    constexpr explicit(
        !conjunction_v&lt;_Is_implicitly_default_constructible&lt;_Uty1&gt;, _Is_implicitly_default_constructible&lt;_Uty2&gt;&gt;) pair()
        noexcept(is_nothrow_default_constructible_v&lt;_Uty1&gt; &amp;&amp; is_nothrow_default_constructible_v&lt;_Uty2&gt;) // strengthened
        : first(), second() {}

    template &lt;class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t&lt;conjunction_v&lt;is_copy_constructible&lt;_Uty1&gt;, is_copy_constructible&lt;_Uty2&gt;&gt;, int&gt; = 0&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;const _Uty1&amp;, _Uty1&gt;, is_convertible&lt;const _Uty2&amp;, _Uty2&gt;&gt;)
        pair(const _Ty1&amp; _Val1, const _Ty2&amp; _Val2)
            noexcept(is_nothrow_copy_constructible_v&lt;_Uty1&gt; &amp;&amp; is_nothrow_copy_constructible_v&lt;_Uty2&gt;) // strengthened
        : first(_Val1), second(_Val2) {}

#if _HAS_CXX23
    template &lt;class _Other1 = _Ty1, class _Other2 = _Ty2,
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
    template &lt;class _Other1, class _Other2,
#endif // ^^^ !_HAS_CXX23 ^^^
        enable_if_t&lt;conjunction_v&lt;is_constructible&lt;_Ty1, _Other1&gt;, is_constructible&lt;_Ty2, _Other2&gt;&gt;, int&gt; = 0&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;_Other1, _Ty1&gt;, is_convertible&lt;_Other2, _Ty2&gt;&gt;)
        pair(_Other1&amp;&amp; _Val1, _Other2&amp;&amp; _Val2) noexcept(
            is_nothrow_constructible_v&lt;_Ty1, _Other1&gt; &amp;&amp; is_nothrow_constructible_v&lt;_Ty2, _Other2&gt;) // strengthened
<span style = "background-color:#fdd">        : first(_STD forward&lt;_Other1&gt;(_Val1)), second(_STD forward&lt;_Other2&gt;(_Val2)) {
    }</span>

<span style = "background-color:#fdd">    pair(const pair&amp;) = default;</span>
    pair(pair&amp;&amp;)      = default;

#if _HAS_CXX23
    template &lt;class _Other1, class _Other2&gt;
        requires is_constructible_v&lt;_Ty1, _Other1&amp;&gt; &amp;&amp; is_constructible_v&lt;_Ty2, _Other2&amp;&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;_Other1&amp;, _Ty1&gt;, is_convertible&lt;_Other2&amp;, _Ty2&gt;&gt;)
        pair(pair&lt;_Other1, _Other2&gt;&amp; _Right) noexcept(
            is_nothrow_constructible_v&lt;_Ty1, _Other1&amp;&gt; &amp;&amp; is_nothrow_constructible_v&lt;_Ty2, _Other2&amp;&gt;) // strengthened
        : first(_Right.first), second(_Right.second) {}
#endif // _HAS_CXX23

    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;is_constructible&lt;_Ty1, const _Other1&amp;&gt;, is_constructible&lt;_Ty2, const _Other2&amp;&gt;&gt;,
            int&gt; = 0&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;const _Other1&amp;, _Ty1&gt;, is_convertible&lt;const _Other2&amp;, _Ty2&gt;&gt;)
        pair(const pair&lt;_Other1, _Other2&gt;&amp; _Right)
            noexcept(is_nothrow_constructible_v&lt;_Ty1, const _Other1&amp;&gt;
                     &amp;&amp; is_nothrow_constructible_v&lt;_Ty2, const _Other2&amp;&gt;) // strengthened
        : first(_Right.first), second(_Right.second) {}

    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;is_constructible&lt;_Ty1, _Other1&gt;, is_constructible&lt;_Ty2, _Other2&gt;&gt;, int&gt; = 0&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;_Other1, _Ty1&gt;, is_convertible&lt;_Other2, _Ty2&gt;&gt;)
        pair(pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right) noexcept(
            is_nothrow_constructible_v&lt;_Ty1, _Other1&gt; &amp;&amp; is_nothrow_constructible_v&lt;_Ty2, _Other2&gt;) // strengthened
        : first(_STD forward&lt;_Other1&gt;(_Right.first)), second(_STD forward&lt;_Other2&gt;(_Right.second)) {}

#if _HAS_CXX23
    template &lt;class _Other1, class _Other2&gt;
        requires is_constructible_v&lt;_Ty1, const _Other1&gt; &amp;&amp; is_constructible_v&lt;_Ty2, const _Other2&gt;
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;const _Other1, _Ty1&gt;, is_convertible&lt;const _Other2, _Ty2&gt;&gt;)
        pair(const pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right)
            noexcept(is_nothrow_constructible_v&lt;_Ty1, const _Other1&gt;
                     &amp;&amp; is_nothrow_constructible_v&lt;_Ty2, const _Other2&gt;) // strengthened
        : first(_STD forward&lt;const _Other1&gt;(_Right.first)), second(_STD forward&lt;const _Other2&gt;(_Right.second)) {}

#ifdef __EDG__ // TRANSITION, VSO-1900279
    template &lt;class _Other, enable_if_t&lt;_Can_construct_from_pair_like&lt;_Other, _Ty1, _Ty2&gt;, int&gt; = 0&gt;
#else // ^^^ workaround / no workaround vvv
    template &lt;_Pair_like_non_subrange _Other&gt;
        requires conjunction_v&lt;is_constructible&lt;_Ty1, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;,
                     is_constructible&lt;_Ty2, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;&gt;
#endif // ^^^ no workaround ^^^
    constexpr explicit(!conjunction_v&lt;is_convertible&lt;decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;())), _Ty1&gt;,
        is_convertible&lt;decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;())), _Ty2&gt;&gt;) pair(_Other&amp;&amp; _Right)
        noexcept(is_nothrow_constructible_v&lt;_Ty1, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;
                 &amp;&amp; is_nothrow_constructible_v&lt;_Ty2, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;) // strengthened
        : first(_STD get&lt;0&gt;(_STD forward&lt;_Other&gt;(_Right))), second(_STD get&lt;1&gt;(_STD forward&lt;_Other&gt;(_Right))) {
    }
#endif // _HAS_CXX23

    template &lt;class... _Types1, class... _Types2&gt;
    _CONSTEXPR20 pair(piecewise_construct_t, tuple&lt;_Types1...&gt; _Val1, tuple&lt;_Types2...&gt; _Val2)
<span style = "background-color:#fdd">        : pair(_Val1, _Val2, index_sequence_for&lt;_Types1...&gt;{}, index_sequence_for&lt;_Types2...&gt;{}) {}</span>

    pair&amp; operator=(const volatile pair&amp;) = delete;

    template &lt;class _Myself = pair,
        enable_if_t&lt;conjunction_v&lt;_Is_copy_assignable_no_precondition_check&lt;typename _Myself::first_type&gt;,
                        _Is_copy_assignable_no_precondition_check&lt;typename _Myself::second_type&gt;&gt;,
            int&gt;            = 0&gt;
    _CONSTEXPR20 pair&amp; operator=(_Identity_t&lt;const _Myself&amp;&gt; _Right)
        noexcept(conjunction_v&lt;is_nothrow_copy_assignable&lt;_Ty1&gt;, is_nothrow_copy_assignable&lt;_Ty2&gt;&gt;) /* strengthened */ {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }

#if _HAS_CXX23
    template &lt;class _Myself = pair&gt;
        requires _Is_copy_assignable_unchecked_v&lt;const typename _Myself::first_type&gt;
              &amp;&amp; _Is_copy_assignable_unchecked_v&lt;const typename _Myself::second_type&gt;
    constexpr const pair&amp; operator=(_Identity_t&lt;const _Myself&amp;&gt; _Right) const
        noexcept(conjunction_v&lt;is_nothrow_copy_assignable&lt;const _Ty1&gt;,
            is_nothrow_copy_assignable&lt;const _Ty2&gt;&gt;) /* strengthened */ {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }
#endif // _HAS_CXX23

    template &lt;class _Myself = pair,
        enable_if_t&lt;conjunction_v&lt;_Is_move_assignable_no_precondition_check&lt;typename _Myself::first_type&gt;,
                        _Is_move_assignable_no_precondition_check&lt;typename _Myself::second_type&gt;&gt;,
            int&gt;            = 0&gt;
    _CONSTEXPR20 pair&amp; operator=(_Identity_t&lt;_Myself&amp;&amp;&gt; _Right)
        noexcept(conjunction_v&lt;is_nothrow_move_assignable&lt;_Ty1&gt;, is_nothrow_move_assignable&lt;_Ty2&gt;&gt;) /* strengthened */ {
        first  = _STD forward&lt;_Ty1&gt;(_Right.first);
        second = _STD forward&lt;_Ty2&gt;(_Right.second);
        return *this;
    }

#if _HAS_CXX23
    template &lt;class _Myself = pair&gt;
        requires _Is_assignable_no_precondition_check&lt;const typename _Myself::first_type&amp;, _Ty1&gt;::value
              &amp;&amp; _Is_assignable_no_precondition_check&lt;const typename _Myself::second_type&amp;, _Ty2&gt;::value
    constexpr const pair&amp; operator=(_Identity_t&lt;_Myself&amp;&amp;&gt; _Right) const
        noexcept(conjunction_v&lt;is_nothrow_assignable&lt;const _Ty1&amp;, _Ty1&gt;,
            is_nothrow_assignable&lt;const _Ty2&amp;, _Ty2&gt;&gt;) /* strengthened */ {
        first  = _STD forward&lt;_Ty1&gt;(_Right.first);
        second = _STD forward&lt;_Ty2&gt;(_Right.second);
        return *this;
    }
#endif // _HAS_CXX23

    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;negation&lt;is_same&lt;pair, pair&lt;_Other1, _Other2&gt;&gt;&gt;, is_assignable&lt;_Ty1&amp;, const _Other1&amp;&gt;,
                        is_assignable&lt;_Ty2&amp;, const _Other2&amp;&gt;&gt;,
            int&gt; = 0&gt;
    _CONSTEXPR20 pair&amp; operator=(const pair&lt;_Other1, _Other2&gt;&amp; _Right)
        noexcept(is_nothrow_assignable_v&lt;_Ty1&amp;, const _Other1&amp;&gt;
                 &amp;&amp; is_nothrow_assignable_v&lt;_Ty2&amp;, const _Other2&amp;&gt;) /* strengthened */ {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }

#if _HAS_CXX23
    template &lt;class _Other1, class _Other2&gt;
        requires (!is_same_v&lt;pair, pair&lt;_Other1, _Other2&gt;&gt;)
              &amp;&amp; is_assignable_v&lt;const _Ty1&amp;, const _Other1&amp;&gt; &amp;&amp; is_assignable_v&lt;const _Ty2&amp;, const _Other2&amp;&gt;
    constexpr const pair&amp; operator=(const pair&lt;_Other1, _Other2&gt;&amp; _Right) const
        noexcept(is_nothrow_assignable_v&lt;const _Ty1&amp;, const _Other1&amp;&gt;
                 &amp;&amp; is_nothrow_assignable_v&lt;const _Ty2&amp;, const _Other2&amp;&gt;) /* strengthened */ {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }
#endif // _HAS_CXX23

    template &lt;class _Other1, class _Other2,
        enable_if_t&lt;conjunction_v&lt;negation&lt;is_same&lt;pair, pair&lt;_Other1, _Other2&gt;&gt;&gt;, is_assignable&lt;_Ty1&amp;, _Other1&gt;,
                        is_assignable&lt;_Ty2&amp;, _Other2&gt;&gt;,
            int&gt; = 0&gt;
    _CONSTEXPR20 pair&amp; operator=(pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right) noexcept(
        is_nothrow_assignable_v&lt;_Ty1&amp;, _Other1&gt; &amp;&amp; is_nothrow_assignable_v&lt;_Ty2&amp;, _Other2&gt;) /* strengthened */ {
        first  = _STD forward&lt;_Other1&gt;(_Right.first);
        second = _STD forward&lt;_Other2&gt;(_Right.second);
        return *this;
    }

#if _HAS_CXX23
    template &lt;class _Other1, class _Other2&gt;
        requires (!is_same_v&lt;pair, pair&lt;_Other1, _Other2&gt;&gt;)
              &amp;&amp; is_assignable_v&lt;const _Ty1&amp;, _Other1&gt; &amp;&amp; is_assignable_v&lt;const _Ty2&amp;, _Other2&gt;
    constexpr const pair&amp; operator=(pair&lt;_Other1, _Other2&gt;&amp;&amp; _Right) const
        noexcept(is_nothrow_assignable_v&lt;const _Ty1&amp;, _Other1&gt;
                 &amp;&amp; is_nothrow_assignable_v&lt;const _Ty2&amp;, _Other2&gt;) /* strengthened */ {
        first  = _STD forward&lt;_Other1&gt;(_Right.first);
        second = _STD forward&lt;_Other2&gt;(_Right.second);
        return *this;
    }

    template &lt;_Pair_like_non_subrange _Other&gt;
        requires _Different_from&lt;_Other, pair&gt; &amp;&amp; is_assignable_v&lt;_Ty1&amp;, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;
              &amp;&amp; is_assignable_v&lt;_Ty2&amp;, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;
    constexpr pair&amp; operator=(_Other&amp;&amp; _Right)
        noexcept(is_nothrow_assignable_v&lt;_Ty1&amp;, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;
                 &amp;&amp; is_nothrow_assignable_v&lt;_Ty2&amp;, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;) /* strengthened */ {
        first  = _STD get&lt;0&gt;(_STD forward&lt;_Other&gt;(_Right));
        second = _STD get&lt;1&gt;(_STD forward&lt;_Other&gt;(_Right));
        return *this;
    }

    template &lt;_Pair_like_non_subrange _Other&gt;
        requires _Different_from&lt;_Other, pair&gt;
              &amp;&amp; is_assignable_v&lt;const _Ty1&amp;, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;
              &amp;&amp; is_assignable_v&lt;const _Ty2&amp;, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;
    constexpr const pair&amp; operator=(_Other&amp;&amp; _Right) const noexcept(
        is_nothrow_assignable_v&lt;const _Ty1&amp;, decltype(_STD get&lt;0&gt;(_STD declval&lt;_Other&gt;()))&gt;
        &amp;&amp; is_nothrow_assignable_v&lt;const _Ty2&amp;, decltype(_STD get&lt;1&gt;(_STD declval&lt;_Other&gt;()))&gt;) /* strengthened */ {
        first  = _STD get&lt;0&gt;(_STD forward&lt;_Other&gt;(_Right));
        second = _STD get&lt;1&gt;(_STD forward&lt;_Other&gt;(_Right));
        return *this;
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 void swap(pair&amp; _Right)
        noexcept(_Is_nothrow_swappable&lt;_Ty1&gt;::value &amp;&amp; _Is_nothrow_swappable&lt;_Ty2&gt;::value) {
        using _STD swap;
        swap(first, _Right.first); // intentional ADL
        swap(second, _Right.second); // intentional ADL
    }

#if _HAS_CXX23
    template &lt;int = 0&gt; // see GH-3013
    constexpr void swap(const pair&amp; _Right) const
        noexcept(is_nothrow_swappable_v&lt;const _Ty1&gt; &amp;&amp; is_nothrow_swappable_v&lt;const _Ty2&gt;) {
        using _STD swap;
        swap(first, _Right.first); // intentional ADL
        swap(second, _Right.second); // intentional ADL
    }
#endif // _HAS_CXX23

    _Ty1 first; // the first stored value
    _Ty2 second; // the second stored value

private:
    template &lt;class _Tuple1, class _Tuple2, size_t... _Indices1, size_t... _Indices2&gt;
    constexpr pair(_Tuple1&amp; _Val1, _Tuple2&amp; _Val2, index_sequence&lt;_Indices1...&gt;, index_sequence&lt;_Indices2...&gt;)
<span style = "background-color:#fdd">        : first(_STD _Tuple_get&lt;_Indices1&gt;(_STD move(_Val1))...),
          second(_STD _Tuple_get&lt;_Indices2&gt;(_STD move(_Val2))...) {}</span>
};

#if _HAS_CXX17
template &lt;class _Ty1, class _Ty2&gt;
pair(_Ty1, _Ty2) -&gt; pair&lt;_Ty1, _Ty2&gt;;
#endif // _HAS_CXX17

_EXPORT_STD template &lt;class _Ty1, class _Ty2,
    enable_if_t&lt;_Is_swappable&lt;_Ty1&gt;::value &amp;&amp; _Is_swappable&lt;_Ty2&gt;::value, int&gt; = 0&gt;
_CONSTEXPR20 void swap(pair&lt;_Ty1, _Ty2&gt;&amp; _Left, pair&lt;_Ty1, _Ty2&gt;&amp; _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}

#if _HAS_CXX23
_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
    requires is_swappable&lt;const _Ty1&gt;::value &amp;&amp; is_swappable&lt;const _Ty2&gt;::value // TRANSITION, /permissive needs ::value
constexpr void swap(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Ty1, _Ty2&gt;&amp; _Right)
    noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}
#endif // _HAS_CXX23

_EXPORT_STD template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2&gt;
_NODISCARD constexpr bool operator==(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Uty1, _Uty2&gt;&amp; _Right) {
    return _Left.first == _Right.first &amp;&amp; _Left.second == _Right.second;
}

#if _HAS_CXX20
_EXPORT_STD template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2&gt;
_NODISCARD constexpr common_comparison_category_t&lt;_Synth_three_way_result&lt;_Ty1, _Uty1&gt;,
    _Synth_three_way_result&lt;_Ty2, _Uty2&gt;&gt;
    operator&lt;=&gt;(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Uty1, _Uty2&gt;&amp; _Right) {
    if (auto _Result = _Synth_three_way{}(_Left.first, _Right.first); _Result != 0) {
        return _Result;
    }
    return _Synth_three_way{}(_Left.second, _Right.second);
}
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2&gt;
_NODISCARD constexpr bool operator!=(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Uty1, _Uty2&gt;&amp; _Right) {
    return !(_Left == _Right);
}

template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2&gt;
_NODISCARD constexpr bool operator&lt;(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Uty1, _Uty2&gt;&amp; _Right) {
    return _Left.first &lt; _Right.first || (!(_Right.first &lt; _Left.first) &amp;&amp; _Left.second &lt; _Right.second);
}

template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2&gt;
_NODISCARD constexpr bool operator&gt;(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Uty1, _Uty2&gt;&amp; _Right) {
    return _Right &lt; _Left;
}

template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2&gt;
_NODISCARD constexpr bool operator&lt;=(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Uty1, _Uty2&gt;&amp; _Right) {
    return !(_Right &lt; _Left);
}

template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2&gt;
_NODISCARD constexpr bool operator&gt;=(const pair&lt;_Ty1, _Ty2&gt;&amp; _Left, const pair&lt;_Uty1, _Uty2&gt;&amp; _Right) {
    return !(_Left &lt; _Right);
}
#endif // ^^^ !_HAS_CXX20 ^^^

#if _HAS_CXX23
template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2, template &lt;class&gt; class _TQual,
    template &lt;class&gt; class _UQual&gt;
    requires requires {
        typename pair&lt;common_reference_t&lt;_TQual&lt;_Ty1&gt;, _UQual&lt;_Uty1&gt;&gt;, common_reference_t&lt;_TQual&lt;_Ty2&gt;, _UQual&lt;_Uty2&gt;&gt;&gt;;
    }
struct basic_common_reference&lt;pair&lt;_Ty1, _Ty2&gt;, pair&lt;_Uty1, _Uty2&gt;, _TQual, _UQual&gt; {
    using type = pair&lt;common_reference_t&lt;_TQual&lt;_Ty1&gt;, _UQual&lt;_Uty1&gt;&gt;, common_reference_t&lt;_TQual&lt;_Ty2&gt;, _UQual&lt;_Uty2&gt;&gt;&gt;;
};

template &lt;class _Ty1, class _Ty2, class _Uty1, class _Uty2&gt;
    requires requires { typename pair&lt;common_type_t&lt;_Ty1, _Uty1&gt;, common_type_t&lt;_Ty2, _Uty2&gt;&gt;; }
struct common_type&lt;pair&lt;_Ty1, _Ty2&gt;, pair&lt;_Uty1, _Uty2&gt;&gt; {
    using type = pair&lt;common_type_t&lt;_Ty1, _Uty1&gt;, common_type_t&lt;_Ty2, _Uty2&gt;&gt;;
};
#endif // _HAS_CXX23

template &lt;class _Ty&gt;
struct _Unrefwrap_helper { // leave unchanged if not a reference_wrapper
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct _Unrefwrap_helper&lt;reference_wrapper&lt;_Ty&gt;&gt; { // make a reference from a reference_wrapper
    using type = _Ty&amp;;
};

// decay, then unwrap a reference_wrapper
template &lt;class _Ty&gt;
using _Unrefwrap_t = typename _Unrefwrap_helper&lt;decay_t&lt;_Ty&gt;&gt;::type;

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr pair&lt;_Unrefwrap_t&lt;_Ty1&gt;, _Unrefwrap_t&lt;_Ty2&gt;&gt; make_pair(_Ty1&amp;&amp; _Val1, _Ty2&amp;&amp; _Val2)
    noexcept(is_nothrow_constructible_v&lt;_Unrefwrap_t&lt;_Ty1&gt;, _Ty1&gt;
             &amp;&amp; is_nothrow_constructible_v&lt;_Unrefwrap_t&lt;_Ty2&gt;, _Ty2&gt;) /* strengthened */ {
    // return pair composed from arguments
    using _Mypair = pair&lt;_Unrefwrap_t&lt;_Ty1&gt;, _Unrefwrap_t&lt;_Ty2&gt;&gt;;
    return _Mypair(_STD forward&lt;_Ty1&gt;(_Val1), _STD forward&lt;_Ty2&gt;(_Val2));
}

namespace _CXX20_DEPRECATE_REL_OPS rel_ops {
    _EXPORT_STD template &lt;class _Ty&gt;
    _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator!=(const _Ty&amp; _Left, const _Ty&amp; _Right) {
        return !(_Left == _Right);
    }

    _EXPORT_STD template &lt;class _Ty&gt;
    _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator&gt;(const _Ty&amp; _Left, const _Ty&amp; _Right) {
        return _Right &lt; _Left;
    }

    _EXPORT_STD template &lt;class _Ty&gt;
    _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator&lt;=(const _Ty&amp; _Left, const _Ty&amp; _Right) {
        return !(_Right &lt; _Left);
    }

    _EXPORT_STD template &lt;class _Ty&gt;
    _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator&gt;=(const _Ty&amp; _Left, const _Ty&amp; _Right) {
        return !(_Left &lt; _Right);
    }
} // namespace _CXX20_DEPRECATE_REL_OPS rel_ops

template &lt;class _Tuple, class = void&gt;
struct _Tuple_size_sfinae {}; // selected when tuple_size&lt;_Tuple&gt;::value isn't well-formed

template &lt;class _Tuple&gt;
struct _Tuple_size_sfinae&lt;_Tuple, void_t&lt;decltype(tuple_size&lt;_Tuple&gt;::value)&gt;&gt;
    : integral_constant&lt;size_t, tuple_size&lt;_Tuple&gt;::value&gt; {}; // selected when tuple_size&lt;_Tuple&gt;::value is well-formed

template &lt;class _Tuple&gt;
struct tuple_size&lt;const _Tuple&gt; : _Tuple_size_sfinae&lt;_Tuple&gt; {}; // ignore cv

template &lt;class _Tuple&gt;
struct _CXX20_DEPRECATE_VOLATILE tuple_size&lt;volatile _Tuple&gt; : _Tuple_size_sfinae&lt;_Tuple&gt; {}; // ignore cv

template &lt;class _Tuple&gt;
struct _CXX20_DEPRECATE_VOLATILE tuple_size&lt;const volatile _Tuple&gt; : _Tuple_size_sfinae&lt;_Tuple&gt; {}; // ignore cv

template &lt;size_t _Index, class _Tuple&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Index, const _Tuple&gt; : tuple_element&lt;_Index, _Tuple&gt; {
    using _Mybase = tuple_element&lt;_Index, _Tuple&gt;;
    using type    = add_const_t&lt;typename _Mybase::type&gt;;
};

template &lt;size_t _Index, class _Tuple&gt;
struct _CXX20_DEPRECATE_VOLATILE _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Index, volatile _Tuple&gt;
    : tuple_element&lt;_Index, _Tuple&gt; {
    using _Mybase = tuple_element&lt;_Index, _Tuple&gt;;
    using type    = add_volatile_t&lt;typename _Mybase::type&gt;;
};

template &lt;size_t _Index, class _Tuple&gt;
struct _CXX20_DEPRECATE_VOLATILE _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Index, const volatile _Tuple&gt;
    : tuple_element&lt;_Index, _Tuple&gt; {
    using _Mybase = tuple_element&lt;_Index, _Tuple&gt;;
    using type    = add_cv_t&lt;typename _Mybase::type&gt;;
};

template &lt;class _Ty, size_t _Size&gt;
struct tuple_size&lt;array&lt;_Ty, _Size&gt;&gt; : integral_constant&lt;size_t, _Size&gt; {}; // size of array

template &lt;size_t _Idx, class _Ty, size_t _Size&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Idx, array&lt;_Ty, _Size&gt;&gt; {
    static_assert(_Idx &lt; _Size, "array index out of bounds");

    using type = _Ty;
};

template &lt;class... _Types&gt;
struct tuple_size&lt;tuple&lt;_Types...&gt;&gt; : integral_constant&lt;size_t, sizeof...(_Types)&gt; {}; // size of tuple

template &lt;size_t _Index&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Index, tuple&lt;&gt;&gt; { // enforce bounds checking
    static_assert(_Always_false&lt;integral_constant&lt;size_t, _Index&gt;&gt;, "tuple index out of bounds");
};

template &lt;class _This, class... _Rest&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;0, tuple&lt;_This, _Rest...&gt;&gt; { // select first element
    using type = _This;
    // MSVC assumes the meaning of _Ttype; remove or rename, but do not change semantics
    using _Ttype = tuple&lt;_This, _Rest...&gt;;
};

template &lt;size_t _Index, class _This, class... _Rest&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Index, tuple&lt;_This, _Rest...&gt;&gt;
    : tuple_element&lt;_Index - 1, tuple&lt;_Rest...&gt;&gt; {}; // recursive tuple_element definition

template &lt;class _Ty1, class _Ty2&gt;
struct tuple_size&lt;pair&lt;_Ty1, _Ty2&gt;&gt; : integral_constant&lt;size_t, 2&gt; {}; // size of pair

template &lt;size_t _Idx, class _Ty1, class _Ty2&gt;
struct _MSVC_KNOWN_SEMANTICS tuple_element&lt;_Idx, pair&lt;_Ty1, _Ty2&gt;&gt; {
    static_assert(_Idx &lt; 2, "pair index out of bounds");

    using type = conditional_t&lt;_Idx == 0, _Ty1, _Ty2&gt;;
};

_EXPORT_STD template &lt;size_t _Idx, class _Ty1, class _Ty2&gt;
_NODISCARD constexpr tuple_element_t&lt;_Idx, pair&lt;_Ty1, _Ty2&gt;&gt;&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr _Ty1&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get reference to element _Ty1 in pair _Pr
    return _Pr.first;
}

_EXPORT_STD template &lt;class _Ty2, class _Ty1&gt;
_NODISCARD constexpr _Ty2&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get reference to element _Ty2 in pair _Pr
    return _Pr.second;
}

_EXPORT_STD template &lt;size_t _Idx, class _Ty1, class _Ty2&gt;
_NODISCARD constexpr const tuple_element_t&lt;_Idx, pair&lt;_Ty1, _Ty2&gt;&gt;&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get const reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr const _Ty1&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get const reference to element _Ty1 in pair _Pr
    return _Pr.first;
}

_EXPORT_STD template &lt;class _Ty2, class _Ty1&gt;
_NODISCARD constexpr const _Ty2&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp; _Pr) noexcept {
    // get const reference to element _Ty2 in pair _Pr
    return _Pr.second;
}

_EXPORT_STD template &lt;size_t _Idx, class _Ty1, class _Ty2&gt;
_NODISCARD constexpr tuple_element_t&lt;_Idx, pair&lt;_Ty1, _Ty2&gt;&gt;&amp;&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get rvalue reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _STD forward&lt;_Ty1&gt;(_Pr.first);
    } else {
        return _STD forward&lt;_Ty2&gt;(_Pr.second);
    }
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr _Ty1&amp;&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get rvalue reference to element _Ty1 in pair _Pr
    return _STD forward&lt;_Ty1&gt;(_Pr.first);
}

_EXPORT_STD template &lt;class _Ty2, class _Ty1&gt;
_NODISCARD constexpr _Ty2&amp;&amp; get(pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get rvalue reference to element _Ty2 in pair _Pr
    return _STD forward&lt;_Ty2&gt;(_Pr.second);
}

_EXPORT_STD template &lt;size_t _Idx, class _Ty1, class _Ty2&gt;
_NODISCARD constexpr const tuple_element_t&lt;_Idx, pair&lt;_Ty1, _Ty2&gt;&gt;&amp;&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get const rvalue reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _STD forward&lt;const _Ty1&gt;(_Pr.first);
    } else {
        return _STD forward&lt;const _Ty2&gt;(_Pr.second);
    }
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr const _Ty1&amp;&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get const rvalue reference to element _Ty1 in pair _Pr
    return _STD forward&lt;const _Ty1&gt;(_Pr.first);
}

_EXPORT_STD template &lt;class _Ty2, class _Ty1&gt;
_NODISCARD constexpr const _Ty2&amp;&amp; get(const pair&lt;_Ty1, _Ty2&gt;&amp;&amp; _Pr) noexcept {
    // get const rvalue reference to element _Ty2 in pair _Pr
    return _STD forward&lt;const _Ty2&gt;(_Pr.second);
}

_EXPORT_STD template &lt;class _Ty, class _Other = _Ty&gt;
_CONSTEXPR20 _Ty exchange(_Ty&amp; _Val, _Other&amp;&amp; _New_val)
<span style = "background-color:#dfd">    noexcept(conjunction_v&lt;is_nothrow_move_constructible&lt;_Ty&gt;, is_nothrow_assignable&lt;_Ty&amp;, _Other&gt;&gt;) {</span>
    // assign _New_val to _Val, return previous _Val
<span style = "background-color:#dfd">    _Ty _Old_val = static_cast&lt;_Ty&amp;&amp;&gt;(_Val);
    _Val         = static_cast&lt;_Other&amp;&amp;&gt;(_New_val);
    return _Old_val;
}</span>

_EXPORT_STD template &lt;class _Ty&gt;
_NODISCARD _MSVC_INTRINSIC constexpr add_const_t&lt;_Ty&gt;&amp; as_const(_Ty&amp; _Val) noexcept { // view _Val through const lenses
    return _Val;
}

_EXPORT_STD template &lt;class _Ty&gt;
void as_const(const _Ty&amp;&amp;) = delete;

#if _HAS_CXX17
_EXPORT_STD struct in_place_t { // tag used to select a constructor which initializes a contained object in place
    explicit in_place_t() = default;
};
_EXPORT_STD inline constexpr in_place_t in_place{};

_EXPORT_STD template &lt;class&gt;
struct in_place_type_t { // tag that selects a type to construct in place
    explicit in_place_type_t() = default;
};
_EXPORT_STD template &lt;class _Ty&gt;
constexpr in_place_type_t&lt;_Ty&gt; in_place_type{};

_EXPORT_STD template &lt;size_t&gt;
struct in_place_index_t { // tag that selects the index of a type to construct in place
    explicit in_place_index_t() = default;
};
_EXPORT_STD template &lt;size_t _Idx&gt;
constexpr in_place_index_t&lt;_Idx&gt; in_place_index{};
#endif // _HAS_CXX17

template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool _Cmp_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    _STL_INTERNAL_STATIC_ASSERT(_Is_nonbool_integral&lt;_Ty1&gt; &amp;&amp; _Is_nonbool_integral&lt;_Ty2&gt;); // allows character types
    if constexpr (is_signed_v&lt;_Ty1&gt; == is_signed_v&lt;_Ty2&gt;) {
        return _Left == _Right;
    } else if constexpr (is_signed_v&lt;_Ty2&gt;) {
        return _Left == static_cast&lt;make_unsigned_t&lt;_Ty2&gt;&gt;(_Right) &amp;&amp; _Right &gt;= 0;
    } else {
        return static_cast&lt;make_unsigned_t&lt;_Ty1&gt;&gt;(_Left) == _Right &amp;&amp; _Left &gt;= 0;
    }
}

template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool _Cmp_not_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !_STD _Cmp_equal(_Left, _Right);
}

template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool _Cmp_less(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    _STL_INTERNAL_STATIC_ASSERT(_Is_nonbool_integral&lt;_Ty1&gt; &amp;&amp; _Is_nonbool_integral&lt;_Ty2&gt;); // allows character types
    if constexpr (is_signed_v&lt;_Ty1&gt; == is_signed_v&lt;_Ty2&gt;) {
        return _Left &lt; _Right;
    } else if constexpr (is_signed_v&lt;_Ty2&gt;) {
        return _Right &gt; 0 &amp;&amp; _Left &lt; static_cast&lt;make_unsigned_t&lt;_Ty2&gt;&gt;(_Right);
    } else {
        return _Left &lt; 0 || static_cast&lt;make_unsigned_t&lt;_Ty1&gt;&gt;(_Left) &lt; _Right;
    }
}

template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool _Cmp_greater(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return _STD _Cmp_less(_Right, _Left);
}

template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool _Cmp_less_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !_STD _Cmp_less(_Right, _Left);
}

template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool _Cmp_greater_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !_STD _Cmp_less(_Left, _Right);
}

template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty _Min_limit() noexcept { // same as (numeric_limits&lt;_Ty&gt;::min)(), less throughput cost
    _STL_INTERNAL_STATIC_ASSERT(is_integral_v&lt;_Ty&gt;); // doesn't attempt to handle all types
    if constexpr (is_signed_v&lt;_Ty&gt;) {
        constexpr auto _Unsigned_max = static_cast&lt;make_unsigned_t&lt;_Ty&gt;&gt;(-1);
        return static_cast&lt;_Ty&gt;((_Unsigned_max &gt;&gt; 1) + 1); // well-defined, N4950 [conv.integral]/3
    } else {
        return 0;
    }
}

template &lt;class _Ty&gt;
<span style = "background-color:#dfd">_NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits&lt;_Ty&gt;::max)(), less throughput cost</span>
    _STL_INTERNAL_STATIC_ASSERT(is_integral_v&lt;_Ty&gt;); // doesn't attempt to handle all types
    if constexpr (is_signed_v&lt;_Ty&gt;) {
<span style = "background-color:#dfd">        constexpr auto _Unsigned_max = static_cast&lt;make_unsigned_t&lt;_Ty&gt;&gt;(-1);
        return static_cast&lt;_Ty&gt;(_Unsigned_max &gt;&gt; 1);</span>
    } else {
        return static_cast&lt;_Ty&gt;(-1);
    }
<span style = "background-color:#dfd">}</span>

template &lt;class _Rx, class _Ty&gt;
_NODISCARD constexpr bool _In_range(const _Ty _Value) noexcept {
    _STL_INTERNAL_STATIC_ASSERT(_Is_nonbool_integral&lt;_Rx&gt; &amp;&amp; _Is_nonbool_integral&lt;_Ty&gt;); // allows character types

    constexpr auto _Ty_min = _Min_limit&lt;_Ty&gt;();
    constexpr auto _Rx_min = _Min_limit&lt;_Rx&gt;();

    if constexpr (_STD _Cmp_less(_Ty_min, _Rx_min)) {
        if (_Value &lt; _Ty{_Rx_min}) {
            return false;
        }
    }

    constexpr auto _Ty_max = _Max_limit&lt;_Ty&gt;();
    constexpr auto _Rx_max = _Max_limit&lt;_Rx&gt;();

    if constexpr (_STD _Cmp_greater(_Ty_max, _Rx_max)) {
        if (_Value &gt; _Ty{_Rx_max}) {
            return false;
        }
    }

    return true;
}

#if _HAS_CXX20
template &lt;class _Ty&gt;
constexpr bool _Is_standard_integer = _Is_any_of_v&lt;remove_cv_t&lt;_Ty&gt;, signed char, short, int, long, long long,
    unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long&gt;;

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer&lt;_Ty1&gt; &amp;&amp; _Is_standard_integer&lt;_Ty2&gt;,
        "The integer comparison functions only accept standard and extended integer types.");
    return _STD _Cmp_equal(_Left, _Right);
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_not_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer&lt;_Ty1&gt; &amp;&amp; _Is_standard_integer&lt;_Ty2&gt;,
        "The integer comparison functions only accept standard and extended integer types.");
    return _STD _Cmp_not_equal(_Left, _Right);
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_less(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer&lt;_Ty1&gt; &amp;&amp; _Is_standard_integer&lt;_Ty2&gt;,
        "The integer comparison functions only accept standard and extended integer types.");
    return _STD _Cmp_less(_Left, _Right);
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_greater(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer&lt;_Ty1&gt; &amp;&amp; _Is_standard_integer&lt;_Ty2&gt;,
        "The integer comparison functions only accept standard and extended integer types.");
    return _STD _Cmp_greater(_Left, _Right);
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_less_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer&lt;_Ty1&gt; &amp;&amp; _Is_standard_integer&lt;_Ty2&gt;,
        "The integer comparison functions only accept standard and extended integer types.");
    return _STD _Cmp_less_equal(_Left, _Right);
}

_EXPORT_STD template &lt;class _Ty1, class _Ty2&gt;
_NODISCARD constexpr bool cmp_greater_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer&lt;_Ty1&gt; &amp;&amp; _Is_standard_integer&lt;_Ty2&gt;,
        "The integer comparison functions only accept standard and extended integer types.");
    return _STD _Cmp_greater_equal(_Left, _Right);
}

_EXPORT_STD template &lt;class _Rx, class _Ty&gt;
_NODISCARD constexpr bool in_range(const _Ty _Value) noexcept {
    static_assert(_Is_standard_integer&lt;_Rx&gt; &amp;&amp; _Is_standard_integer&lt;_Ty&gt;,
        "The integer comparison functions only accept standard and extended integer types.");
    return _STD _In_range&lt;_Rx&gt;(_Value);
}
#endif // _HAS_CXX20

#if _HAS_CXX23
_EXPORT_STD template &lt;class _Ty&gt; // TRANSITION, VSO-2253317: should be _MSVC_INTRINSIC
_NODISCARD constexpr underlying_type_t&lt;_Ty&gt; to_underlying(_Ty _Value) noexcept {
    return static_cast&lt;underlying_type_t&lt;_Ty&gt;&gt;(_Value);
}

_EXPORT_STD [[noreturn]] __forceinline void unreachable() noexcept /* strengthened */ {
    _STL_UNREACHABLE;
#ifdef _DEBUG
    _CSTD abort(); // likely to be called in debug mode, but can't be relied upon - already entered the UB territory
#endif // defined(_DEBUG)
}

template &lt;class _Ty, class _Uty,
    class _Tmp = _Maybe_const&lt;is_const_v&lt;remove_reference_t&lt;_Ty&gt;&gt;, remove_reference_t&lt;_Uty&gt;&gt;&gt;
using _Forward_like_t = conditional_t&lt;is_rvalue_reference_v&lt;_Ty&amp;&amp;&gt;, _Tmp&amp;&amp;, _Tmp&amp;&gt;;

_EXPORT_STD template &lt;class _Ty, class _Uty&gt;
_NODISCARD _MSVC_INTRINSIC constexpr _Forward_like_t&lt;_Ty, _Uty&gt; forward_like(_Uty&amp;&amp; _Ux) noexcept {
    return static_cast&lt;_Forward_like_t&lt;_Ty, _Uty&gt;&gt;(_Ux);
}
#endif // _HAS_CXX23

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
    using _STD get;
    using _STD tuple_element;
    using _STD tuple_size;
} // namespace _DEPRECATE_TR1_NAMESPACE tr1
#endif // _HAS_TR1_NAMESPACE

_STD_END

// TRANSITION, non-_Ugly attribute tokens
#pragma pop_macro("lifetimebound")
#pragma pop_macro("known_semantics")
#pragma pop_macro("intrinsic")
#pragma pop_macro("msvc")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _UTILITY_</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>