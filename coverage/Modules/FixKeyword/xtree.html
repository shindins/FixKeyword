<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>xtree</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// xtree internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _XTREE_
#define _XTREE_
#include &lt;yvals_core.h&gt;
#if _STL_COMPILER_PREPROCESSOR
#include &lt;xmemory&gt;

#if _HAS_CXX17
#include &lt;xnode_handle.h&gt;
#endif // _HAS_CXX17

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template &lt;class _Mytree, class _Base = _Iterator_base0&gt;
class _Tree_unchecked_const_iterator : public _Base {
public:
    using iterator_category = bidirectional_iterator_tag;

    using _Nodeptr        = typename _Mytree::_Nodeptr;
    using value_type      = typename _Mytree::value_type;
    using difference_type = typename _Mytree::difference_type;
    using pointer         = typename _Mytree::const_pointer;
    using reference       = const value_type&amp;;

    _Tree_unchecked_const_iterator() noexcept : _Ptr() {}

<span style = "background-color:#fdd">    _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {
        this-&gt;_Adopt(_Plist);
    }</span>

<span style = "background-color:#fdd">    _NODISCARD reference operator*() const noexcept {
        return _Ptr-&gt;_Myval;
    }</span>

    _NODISCARD pointer operator-&gt;() const noexcept {
        return pointer_traits&lt;pointer&gt;::pointer_to(**this);
    }

<span style = "background-color:#fdd">    _Tree_unchecked_const_iterator&amp; operator++() noexcept {
        if (_Ptr-&gt;_Right-&gt;_Isnil) { // climb looking for right subtree</span>
            _Nodeptr _Pnode;
<span style = "background-color:#fdd">            while (!(_Pnode = _Ptr-&gt;_Parent)-&gt;_Isnil &amp;&amp; _Ptr == _Pnode-&gt;_Right) {
                _Ptr = _Pnode; // ==&gt; parent while right subtree
            }</span>

<span style = "background-color:#fdd">            _Ptr = _Pnode; // ==&gt; parent (head if end())
        } else {
            _Ptr = _Mytree::_Min(_Ptr-&gt;_Right); // ==&gt; smallest of right subtree</span>
        }

<span style = "background-color:#fdd">        return *this;
    }</span>

    _Tree_unchecked_const_iterator operator++(int) noexcept {
        _Tree_unchecked_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _Tree_unchecked_const_iterator&amp; operator--() noexcept {
        if (_Ptr-&gt;_Isnil) {
            _Ptr = _Ptr-&gt;_Right; // end() ==&gt; rightmost
        } else if (_Ptr-&gt;_Left-&gt;_Isnil) { // climb looking for left subtree
            _Nodeptr _Pnode;
            while (!(_Pnode = _Ptr-&gt;_Parent)-&gt;_Isnil &amp;&amp; _Ptr == _Pnode-&gt;_Left) {
                _Ptr = _Pnode; // ==&gt; parent while left subtree
            }

            if (!_Ptr-&gt;_Isnil) { // decrement non-begin()
                _Ptr = _Pnode; // ==&gt; parent if not head
            }
        } else {
            _Ptr = _Mytree::_Max(_Ptr-&gt;_Left); // ==&gt; largest of left subtree
        }

        return *this;
    }

    _Tree_unchecked_const_iterator operator--(int) noexcept {
        _Tree_unchecked_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    _NODISCARD bool operator==(const _Tree_unchecked_const_iterator&amp; _Right) const noexcept {
        return _Ptr == _Right._Ptr;
    }

#if !_HAS_CXX20
    _NODISCARD bool operator!=(const _Tree_unchecked_const_iterator&amp; _Right) const noexcept {
        return !(*this == _Right);
    }
#endif // !_HAS_CXX20

    _NODISCARD bool operator==(_Default_sentinel) const noexcept {
        return !!_Ptr-&gt;_Isnil; // TRANSITION, avoid warning C4800:
                               // "Implicit conversion from 'char' to bool. Possible information loss" (/Wall)
    }

#if !_HAS_CXX20
<span style = "background-color:#fdd">    _NODISCARD bool operator!=(_Default_sentinel) const noexcept {
        return !_Ptr-&gt;_Isnil;
    }</span>
#endif // !_HAS_CXX20

    _Nodeptr _Ptr; // pointer to node
};

template &lt;class _Mytree&gt;
class _Tree_unchecked_iterator : public _Tree_unchecked_const_iterator&lt;_Mytree&gt; {
public:
    using _Mybase           = _Tree_unchecked_const_iterator&lt;_Mytree&gt;;
    using iterator_category = bidirectional_iterator_tag;

    using _Nodeptr        = typename _Mytree::_Nodeptr;
    using value_type      = typename _Mytree::value_type;
    using difference_type = typename _Mytree::difference_type;
    using pointer         = typename _Mytree::pointer;
    using reference       = value_type&amp;;

    using _Mybase::_Mybase;

<span style = "background-color:#fdd">    _NODISCARD reference operator*() const noexcept {
        return const_cast&lt;reference&gt;(_Mybase::operator*());
    }</span>

    _NODISCARD pointer operator-&gt;() const noexcept {
        return pointer_traits&lt;pointer&gt;::pointer_to(**this);
    }

<span style = "background-color:#fdd">    _Tree_unchecked_iterator&amp; operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }</span>

    _Tree_unchecked_iterator operator++(int) noexcept {
        _Tree_unchecked_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _Tree_unchecked_iterator&amp; operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _Tree_unchecked_iterator operator--(int) noexcept {
        _Tree_unchecked_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }
};

template &lt;class _Mytree&gt;
class _Tree_const_iterator : public _Tree_unchecked_const_iterator&lt;_Mytree, _Iterator_base&gt; {
public:
    using _Mybase           = _Tree_unchecked_const_iterator&lt;_Mytree, _Iterator_base&gt;;
    using iterator_category = bidirectional_iterator_tag;

    using _Nodeptr        = typename _Mytree::_Nodeptr;
    using value_type      = typename _Mytree::value_type;
    using difference_type = typename _Mytree::difference_type;
    using pointer         = typename _Mytree::const_pointer;
    using reference       = const value_type&amp;;

    using _Mybase::_Mybase;

    _NODISCARD reference operator*() const noexcept {
#if _ITERATOR_DEBUG_LEVEL == 2
        const auto _Mycont = static_cast&lt;const _Mytree*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Mycont, "cannot dereference value-initialized map/set iterator");
        _STL_VERIFY(this-&gt;_Ptr != _Mycont-&gt;_Myhead, "cannot dereference end map/set iterator");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        return this-&gt;_Ptr-&gt;_Myval;
    }

    _NODISCARD pointer operator-&gt;() const noexcept {
        return pointer_traits&lt;pointer&gt;::pointer_to(**this);
    }

    _Tree_const_iterator&amp; operator++() noexcept {
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(this-&gt;_Getcont(), "cannot increment value-initialized map/set iterator");
        _STL_VERIFY(!this-&gt;_Ptr-&gt;_Isnil, "cannot increment end map/set iterator");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Mybase::operator++();
        return *this;
    }

    _Tree_const_iterator operator++(int) noexcept {
        _Tree_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _Tree_const_iterator&amp; operator--() noexcept {
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(this-&gt;_Getcont(), "cannot decrement value-initialized map/set iterator");
        _Nodeptr _Ptrsav = this-&gt;_Ptr;
        _Mybase::operator--();
        _STL_VERIFY(_Ptrsav != this-&gt;_Ptr, "cannot decrement begin map/set iterator");
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
        _Mybase::operator--();
#endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^

        return *this;
    }

    _Tree_const_iterator operator--(int) noexcept {
        _Tree_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    _NODISCARD bool operator==(const _Tree_const_iterator&amp; _Right) const noexcept {
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(this-&gt;_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        return this-&gt;_Ptr == _Right._Ptr;
    }

#if !_HAS_CXX20
    _NODISCARD bool operator!=(const _Tree_const_iterator&amp; _Right) const noexcept {
        return !(*this == _Right);
    }
#endif // !_HAS_CXX20

#if _ITERATOR_DEBUG_LEVEL == 2
    friend void _Verify_range(const _Tree_const_iterator&amp; _First, const _Tree_const_iterator&amp; _Last) noexcept {
        _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "map/set iterators in range are from different containers");
    }
#endif // _ITERATOR_DEBUG_LEVEL == 2

    using _Prevent_inheriting_unwrap = _Tree_const_iterator;

    _NODISCARD _Tree_unchecked_const_iterator&lt;_Mytree&gt; _Unwrapped() const noexcept {
        return _Tree_unchecked_const_iterator&lt;_Mytree&gt;(this-&gt;_Ptr, static_cast&lt;const _Mytree*&gt;(this-&gt;_Getcont()));
    }

    void _Seek_to(const _Tree_unchecked_const_iterator&lt;_Mytree&gt; _It) noexcept {
        this-&gt;_Ptr = _It._Ptr;
    }
};

template &lt;class _Mytree&gt;
class _Tree_iterator : public _Tree_const_iterator&lt;_Mytree&gt; {
public:
    using _Mybase           = _Tree_const_iterator&lt;_Mytree&gt;;
    using iterator_category = bidirectional_iterator_tag;

    using _Nodeptr        = typename _Mytree::_Nodeptr;
    using value_type      = typename _Mytree::value_type;
    using difference_type = typename _Mytree::difference_type;

    using pointer   = typename _Mytree::pointer;
    using reference = value_type&amp;;

    using _Mybase::_Mybase;

    _NODISCARD reference operator*() const noexcept {
        return const_cast&lt;reference&gt;(_Mybase::operator*());
    }

    _NODISCARD pointer operator-&gt;() const noexcept {
        return pointer_traits&lt;pointer&gt;::pointer_to(**this);
    }

    _Tree_iterator&amp; operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    _Tree_iterator operator++(int) noexcept {
        _Tree_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _Tree_iterator&amp; operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _Tree_iterator operator--(int) noexcept {
        _Tree_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    using _Prevent_inheriting_unwrap = _Tree_iterator;

    _NODISCARD _Tree_unchecked_iterator&lt;_Mytree&gt; _Unwrapped() const noexcept {
        return _Tree_unchecked_iterator&lt;_Mytree&gt;(this-&gt;_Ptr, static_cast&lt;const _Mytree*&gt;(this-&gt;_Getcont()));
    }
};

template &lt;class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Nodeptr_type&gt;
struct _Tree_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
    using _Nodeptr        = _Nodeptr_type;
};

template &lt;class _Value_type, class _Voidptr&gt;
struct _Tree_node {
    using _Nodeptr   = _Rebind_pointer_t&lt;_Voidptr, _Tree_node&gt;;
    using value_type = _Value_type;
    _Nodeptr _Left; // left subtree, or smallest element if head
    _Nodeptr _Parent; // parent, or root of tree if head
    _Nodeptr _Right; // right subtree, or largest element if head
    char _Color; // _Red or _Black, _Black if head
    char _Isnil; // true only if head (also nil) node; TRANSITION, should be bool
    value_type _Myval = // the stored value, unused if head
        _Returns_exactly&lt;value_type&gt;(); // fake a viable constructor to workaround GH-2749

    enum _Redbl { // colors for link to parent
        _Red,
        _Black
    };

    _Tree_node()                             = default;
    _Tree_node(const _Tree_node&amp;)            = delete;
    _Tree_node&amp; operator=(const _Tree_node&amp;) = delete;

    template &lt;class _Alloc&gt;
<span style = "background-color:#dfd">    static _Nodeptr _Buyheadnode(_Alloc&amp; _Al) {</span>
        static_assert(is_same_v&lt;typename _Alloc::value_type, _Tree_node&gt;, "Bad _Buyheadnode call");
<span style = "background-color:#dfd">        const auto _Pnode = _Al.allocate(1);
        _Construct_in_place(_Pnode-&gt;_Left, _Pnode);
        _Construct_in_place(_Pnode-&gt;_Parent, _Pnode);
        _Construct_in_place(_Pnode-&gt;_Right, _Pnode);
        _Pnode-&gt;_Color = _Black;
        _Pnode-&gt;_Isnil = true;
        return _Pnode;
    }</span>

    template &lt;class _Alloc, class... _Valty&gt;
<span style = "background-color:#fdd">    static _Nodeptr _Buynode(_Alloc&amp; _Al, _Nodeptr _Myhead, _Valty&amp;&amp;... _Val) {</span>
        // allocate a node with defaults and set links and value
        static_assert(is_same_v&lt;typename _Alloc::value_type, _Tree_node&gt;, "Bad _Buynode call");
<span style = "background-color:#fdd">        _Alloc_construct_ptr&lt;_Alloc&gt; _Newnode(_Al);
        _Newnode._Allocate();
        allocator_traits&lt;_Alloc&gt;::construct(_Al, _STD addressof(_Newnode._Ptr-&gt;_Myval), _STD forward&lt;_Valty&gt;(_Val)...);
        _Construct_in_place(_Newnode._Ptr-&gt;_Left, _Myhead);
        _Construct_in_place(_Newnode._Ptr-&gt;_Parent, _Myhead);
        _Construct_in_place(_Newnode._Ptr-&gt;_Right, _Myhead);
        _Newnode._Ptr-&gt;_Color = _Red;
        _Newnode._Ptr-&gt;_Isnil = false;
        return _Newnode._Release();
    }</span>

    template &lt;class _Alloc&gt;
<span style = "background-color:#dfd">    static void _Freenode0(_Alloc&amp; _Al, _Nodeptr _Ptr) noexcept {</span>
        static_assert(is_same_v&lt;typename _Alloc::value_type, _Tree_node&gt;, "Bad _Freenode0 call");
<span style = "background-color:#dfd">        _Destroy_in_place(_Ptr-&gt;_Left);
        _Destroy_in_place(_Ptr-&gt;_Parent);
        _Destroy_in_place(_Ptr-&gt;_Right);
        allocator_traits&lt;_Alloc&gt;::deallocate(_Al, _Ptr, 1);
    }</span>

    template &lt;class _Alloc&gt;
<span style = "background-color:#fdd">    static void _Freenode(_Alloc&amp; _Al, _Nodeptr _Ptr) noexcept {</span>
        static_assert(is_same_v&lt;typename _Alloc::value_type, _Tree_node&gt;, "Bad _Freenode call");
<span style = "background-color:#fdd">        allocator_traits&lt;_Alloc&gt;::destroy(_Al, _STD addressof(_Ptr-&gt;_Myval));
        _Freenode0(_Al, _Ptr);
    }</span>
};

template &lt;class _Ty&gt;
struct _Tree_simple_types : _Simple_types&lt;_Ty&gt; {
    using _Node    = _Tree_node&lt;_Ty, void*&gt;;
    using _Nodeptr = _Node*;
};

enum class _Tree_child {
    _Right, // perf note: compare with _Right rather than _Left where possible for comparison with zero
    _Left,
    _Unused // indicates that tree child should never be used for insertion
};

template &lt;class _Nodeptr&gt;
struct _Tree_id {
    _Nodeptr _Parent; // the leaf node under which a new node should be inserted
    _Tree_child _Child;
};

template &lt;class _Nodeptr&gt;
struct _Tree_find_result {
    _Tree_id&lt;_Nodeptr&gt; _Location;
    _Nodeptr _Bound;
};

template &lt;class _Nodeptr&gt;
struct _Tree_find_hint_result {
    _Tree_id&lt;_Nodeptr&gt; _Location;
    bool _Duplicate;
};

<span style = "background-color:#fdd">[[noreturn]] inline void _Throw_tree_length_error() {
    _Xlength_error("map/set too long");
}</span>

template &lt;class _Val_types&gt;
class _Tree_val : public _Container_base {
public:
    using _Nodeptr = typename _Val_types::_Nodeptr;

    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&amp;;
    using const_reference = const value_type&amp;;

    using _Unchecked_const_iterator = _Tree_unchecked_const_iterator&lt;_Tree_val&gt;;
    using const_iterator            = _Tree_const_iterator&lt;_Tree_val&gt;;

    template &lt;class _Alnode&gt;
    struct _NODISCARD _Erase_tree_and_orphan_guard {
        _Tree_val* _Val_ptr;
        _Alnode&amp; _Al;
        _Nodeptr _New_root;

        _Erase_tree_and_orphan_guard&amp; operator=(const _Erase_tree_and_orphan_guard&amp;) = delete;
<span style = "background-color:#fdd">        ~_Erase_tree_and_orphan_guard() noexcept {
            if (_Val_ptr != nullptr) {
                _Val_ptr-&gt;_Erase_tree_and_orphan(_Al, _New_root); // subtree copy failed, bail out</span>
            }
<span style = "background-color:#fdd">        }</span>
    };

<span style = "background-color:#dfd">    _Tree_val() noexcept : _Myhead(), _Mysize(0) {}</span>

#if _MSVC_STL_DESTRUCTOR_TOMBSTONES
    ~_Tree_val() noexcept {
        if constexpr (is_pointer_v&lt;_Nodeptr&gt;) {
            const auto _Tombstone{reinterpret_cast&lt;_Nodeptr&gt;(_MSVC_STL_UINTPTR_TOMBSTONE_VALUE)};
            _Myhead = _Tombstone;
            _Mysize = 0;
        }
    }
#endif // _MSVC_STL_DESTRUCTOR_TOMBSTONES

    enum _Redbl { // colors for link to parent
        _Red,
        _Black
    };

<span style = "background-color:#fdd">    static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode
        while (!_Pnode-&gt;_Right-&gt;_Isnil) {
            _Pnode = _Pnode-&gt;_Right;
        }</span>

<span style = "background-color:#fdd">        return _Pnode;
    }</span>

<span style = "background-color:#fdd">    static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode
        while (!_Pnode-&gt;_Left-&gt;_Isnil) {
            _Pnode = _Pnode-&gt;_Left;
        }</span>

<span style = "background-color:#fdd">        return _Pnode;
    }</span>

<span style = "background-color:#fdd">    void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree
        _Nodeptr _Pnode    = _Wherenode-&gt;_Right;
        _Wherenode-&gt;_Right = _Pnode-&gt;_Left;</span>

<span style = "background-color:#fdd">        if (!_Pnode-&gt;_Left-&gt;_Isnil) {
            _Pnode-&gt;_Left-&gt;_Parent = _Wherenode;</span>
        }

<span style = "background-color:#fdd">        _Pnode-&gt;_Parent = _Wherenode-&gt;_Parent;</span>

<span style = "background-color:#fdd">        if (_Wherenode == _Myhead-&gt;_Parent) {
            _Myhead-&gt;_Parent = _Pnode;
        } else if (_Wherenode == _Wherenode-&gt;_Parent-&gt;_Left) {
            _Wherenode-&gt;_Parent-&gt;_Left = _Pnode;
        } else {
            _Wherenode-&gt;_Parent-&gt;_Right = _Pnode;</span>
        }

<span style = "background-color:#fdd">        _Pnode-&gt;_Left       = _Wherenode;
        _Wherenode-&gt;_Parent = _Pnode;
    }</span>

<span style = "background-color:#fdd">    void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree
        _Nodeptr _Pnode   = _Wherenode-&gt;_Left;
        _Wherenode-&gt;_Left = _Pnode-&gt;_Right;</span>

<span style = "background-color:#fdd">        if (!_Pnode-&gt;_Right-&gt;_Isnil) {
            _Pnode-&gt;_Right-&gt;_Parent = _Wherenode;</span>
        }

<span style = "background-color:#fdd">        _Pnode-&gt;_Parent = _Wherenode-&gt;_Parent;</span>

<span style = "background-color:#fdd">        if (_Wherenode == _Myhead-&gt;_Parent) {
            _Myhead-&gt;_Parent = _Pnode;
        } else if (_Wherenode == _Wherenode-&gt;_Parent-&gt;_Right) {
            _Wherenode-&gt;_Parent-&gt;_Right = _Pnode;
        } else {
            _Wherenode-&gt;_Parent-&gt;_Left = _Pnode;</span>
        }

<span style = "background-color:#fdd">        _Pnode-&gt;_Right      = _Wherenode;
        _Wherenode-&gt;_Parent = _Pnode;
    }</span>

    _Nodeptr _Extract(_Unchecked_const_iterator _Where) noexcept {
        _Nodeptr _Erasednode = _Where._Ptr; // node to erase
        ++_Where; // save successor iterator for return

        _Nodeptr _Fixnode; // the node to recolor as needed
        _Nodeptr _Fixnodeparent; // parent of _Fixnode (which may be nil)
        _Nodeptr _Pnode = _Erasednode;

        if (_Pnode-&gt;_Left-&gt;_Isnil) {
            _Fixnode = _Pnode-&gt;_Right; // stitch up right subtree
        } else if (_Pnode-&gt;_Right-&gt;_Isnil) {
            _Fixnode = _Pnode-&gt;_Left; // stitch up left subtree
        } else { // two subtrees, must lift successor node to replace erased
            _Pnode   = _Where._Ptr; // _Pnode is successor node
            _Fixnode = _Pnode-&gt;_Right; // _Fixnode is only subtree
        }

        if (_Pnode == _Erasednode) { // at most one subtree, relink it
            _Fixnodeparent = _Erasednode-&gt;_Parent;
            if (!_Fixnode-&gt;_Isnil) {
                _Fixnode-&gt;_Parent = _Fixnodeparent; // link up
            }

            if (_Myhead-&gt;_Parent == _Erasednode) {
                _Myhead-&gt;_Parent = _Fixnode; // link down from root
            } else if (_Fixnodeparent-&gt;_Left == _Erasednode) {
                _Fixnodeparent-&gt;_Left = _Fixnode; // link down to left
            } else {
                _Fixnodeparent-&gt;_Right = _Fixnode; // link down to right
            }

            if (_Myhead-&gt;_Left == _Erasednode) {
                _Myhead-&gt;_Left = _Fixnode-&gt;_Isnil ? _Fixnodeparent // smallest is parent of erased node
                                                  : _Min(_Fixnode); // smallest in relinked subtree
            }

            if (_Myhead-&gt;_Right == _Erasednode) {
                _Myhead-&gt;_Right = _Fixnode-&gt;_Isnil ? _Fixnodeparent // largest is parent of erased node
                                                   : _Max(_Fixnode); // largest in relinked subtree
            }
        } else { // erased has two subtrees, _Pnode is successor to erased
            _Erasednode-&gt;_Left-&gt;_Parent = _Pnode; // link left up
            _Pnode-&gt;_Left               = _Erasednode-&gt;_Left; // link successor down

            if (_Pnode == _Erasednode-&gt;_Right) {
                _Fixnodeparent = _Pnode; // successor is next to erased
            } else { // successor further down, link in place of erased
                _Fixnodeparent = _Pnode-&gt;_Parent; // parent is successor's
                if (!_Fixnode-&gt;_Isnil) {
                    _Fixnode-&gt;_Parent = _Fixnodeparent; // link fix up
                }

                _Fixnodeparent-&gt;_Left        = _Fixnode; // link fix down
                _Pnode-&gt;_Right               = _Erasednode-&gt;_Right; // link next down
                _Erasednode-&gt;_Right-&gt;_Parent = _Pnode; // right up
            }

            if (_Myhead-&gt;_Parent == _Erasednode) {
                _Myhead-&gt;_Parent = _Pnode; // link down from root
            } else if (_Erasednode-&gt;_Parent-&gt;_Left == _Erasednode) {
                _Erasednode-&gt;_Parent-&gt;_Left = _Pnode; // link down to left
            } else {
                _Erasednode-&gt;_Parent-&gt;_Right = _Pnode; // link down to right
            }

            _Pnode-&gt;_Parent = _Erasednode-&gt;_Parent; // link successor up
            _STD swap(_Pnode-&gt;_Color, _Erasednode-&gt;_Color); // recolor it
        }

        if (_Erasednode-&gt;_Color == _Black) { // erasing black link, must recolor/rebalance tree
            for (; _Fixnode != _Myhead-&gt;_Parent &amp;&amp; _Fixnode-&gt;_Color == _Black; _Fixnodeparent = _Fixnode-&gt;_Parent) {
                if (_Fixnode == _Fixnodeparent-&gt;_Left) { // fixup left subtree
                    _Pnode = _Fixnodeparent-&gt;_Right;
                    if (_Pnode-&gt;_Color == _Red) { // rotate red up from right subtree
                        _Pnode-&gt;_Color         = _Black;
                        _Fixnodeparent-&gt;_Color = _Red;
                        _Lrotate(_Fixnodeparent);
                        _Pnode = _Fixnodeparent-&gt;_Right;
                    }

                    if (_Pnode-&gt;_Isnil) {
                        _Fixnode = _Fixnodeparent; // shouldn't happen
                    } else if (_Pnode-&gt;_Left-&gt;_Color == _Black
                               &amp;&amp; _Pnode-&gt;_Right-&gt;_Color == _Black) { // redden right subtree with black children
                        _Pnode-&gt;_Color = _Red;
                        _Fixnode       = _Fixnodeparent;
                    } else { // must rearrange right subtree
                        if (_Pnode-&gt;_Right-&gt;_Color == _Black) { // rotate red up from left sub-subtree
                            _Pnode-&gt;_Left-&gt;_Color = _Black;
                            _Pnode-&gt;_Color        = _Red;
                            _Rrotate(_Pnode);
                            _Pnode = _Fixnodeparent-&gt;_Right;
                        }

                        _Pnode-&gt;_Color         = _Fixnodeparent-&gt;_Color;
                        _Fixnodeparent-&gt;_Color = _Black;
                        _Pnode-&gt;_Right-&gt;_Color = _Black;
                        _Lrotate(_Fixnodeparent);
                        break; // tree now recolored/rebalanced
                    }
                } else { // fixup right subtree
                    _Pnode = _Fixnodeparent-&gt;_Left;
                    if (_Pnode-&gt;_Color == _Red) { // rotate red up from left subtree
                        _Pnode-&gt;_Color         = _Black;
                        _Fixnodeparent-&gt;_Color = _Red;
                        _Rrotate(_Fixnodeparent);
                        _Pnode = _Fixnodeparent-&gt;_Left;
                    }

                    if (_Pnode-&gt;_Isnil) {
                        _Fixnode = _Fixnodeparent; // shouldn't happen
                    } else if (_Pnode-&gt;_Right-&gt;_Color == _Black
                               &amp;&amp; _Pnode-&gt;_Left-&gt;_Color == _Black) { // redden left subtree with black children
                        _Pnode-&gt;_Color = _Red;
                        _Fixnode       = _Fixnodeparent;
                    } else { // must rearrange left subtree
                        if (_Pnode-&gt;_Left-&gt;_Color == _Black) { // rotate red up from right sub-subtree
                            _Pnode-&gt;_Right-&gt;_Color = _Black;
                            _Pnode-&gt;_Color         = _Red;
                            _Lrotate(_Pnode);
                            _Pnode = _Fixnodeparent-&gt;_Left;
                        }

                        _Pnode-&gt;_Color         = _Fixnodeparent-&gt;_Color;
                        _Fixnodeparent-&gt;_Color = _Black;
                        _Pnode-&gt;_Left-&gt;_Color  = _Black;
                        _Rrotate(_Fixnodeparent);
                        break; // tree now recolored/rebalanced
                    }
                }
            }

            _Fixnode-&gt;_Color = _Black; // stopping node is black
        }

        if (0 &lt; _Mysize) {
            --_Mysize;
        }

        return _Erasednode;
    }

<span style = "background-color:#fdd">    _Nodeptr _Insert_node(const _Tree_id&lt;_Nodeptr&gt; _Loc, const _Nodeptr _Newnode) noexcept {
        ++_Mysize;
        const auto _Head  = _Myhead;
        _Newnode-&gt;_Parent = _Loc._Parent;
        if (_Loc._Parent == _Head) { // first node in tree, just set head values
            _Head-&gt;_Left     = _Newnode;
            _Head-&gt;_Parent   = _Newnode;
            _Head-&gt;_Right    = _Newnode;
            _Newnode-&gt;_Color = _Black; // the root is black
            return _Newnode;</span>
        }

        _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
<span style = "background-color:#fdd">        if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent</span>
            _STL_INTERNAL_CHECK(_Loc._Parent-&gt;_Right-&gt;_Isnil);
<span style = "background-color:#fdd">            _Loc._Parent-&gt;_Right = _Newnode;
            if (_Loc._Parent == _Head-&gt;_Right) { // remember rightmost node
                _Head-&gt;_Right = _Newnode;</span>
            }
<span style = "background-color:#fdd">        } else { // add to left of _Loc._Parent</span>
            _STL_INTERNAL_CHECK(_Loc._Parent-&gt;_Left-&gt;_Isnil);
<span style = "background-color:#fdd">            _Loc._Parent-&gt;_Left = _Newnode;
            if (_Loc._Parent == _Head-&gt;_Left) { // remember leftmost node
                _Head-&gt;_Left = _Newnode;</span>
            }
        }

<span style = "background-color:#fdd">        for (_Nodeptr _Pnode = _Newnode; _Pnode-&gt;_Parent-&gt;_Color == _Red;) {
            if (_Pnode-&gt;_Parent == _Pnode-&gt;_Parent-&gt;_Parent-&gt;_Left) { // fixup red-red in left subtree
                const auto _Parent_sibling = _Pnode-&gt;_Parent-&gt;_Parent-&gt;_Right;
                if (_Parent_sibling-&gt;_Color == _Red) { // parent's sibling has two red children, blacken both
                    _Pnode-&gt;_Parent-&gt;_Color          = _Black;
                    _Parent_sibling-&gt;_Color          = _Black;
                    _Pnode-&gt;_Parent-&gt;_Parent-&gt;_Color = _Red;
                    _Pnode                           = _Pnode-&gt;_Parent-&gt;_Parent;
                } else { // parent's sibling has red and black children
                    if (_Pnode == _Pnode-&gt;_Parent-&gt;_Right) { // rotate right child to left
                        _Pnode = _Pnode-&gt;_Parent;
                        _Lrotate(_Pnode);</span>
                    }

<span style = "background-color:#fdd">                    _Pnode-&gt;_Parent-&gt;_Color          = _Black; // propagate red up
                    _Pnode-&gt;_Parent-&gt;_Parent-&gt;_Color = _Red;
                    _Rrotate(_Pnode-&gt;_Parent-&gt;_Parent);</span>
                }
<span style = "background-color:#fdd">            } else { // fixup red-red in right subtree
                const auto _Parent_sibling = _Pnode-&gt;_Parent-&gt;_Parent-&gt;_Left;
                if (_Parent_sibling-&gt;_Color == _Red) { // parent's sibling has two red children, blacken both
                    _Pnode-&gt;_Parent-&gt;_Color          = _Black;
                    _Parent_sibling-&gt;_Color          = _Black;
                    _Pnode-&gt;_Parent-&gt;_Parent-&gt;_Color = _Red;
                    _Pnode                           = _Pnode-&gt;_Parent-&gt;_Parent;
                } else { // parent's sibling has red and black children
                    if (_Pnode == _Pnode-&gt;_Parent-&gt;_Left) { // rotate left child to right
                        _Pnode = _Pnode-&gt;_Parent;
                        _Rrotate(_Pnode);</span>
                    }

<span style = "background-color:#fdd">                    _Pnode-&gt;_Parent-&gt;_Color          = _Black; // propagate red up
                    _Pnode-&gt;_Parent-&gt;_Parent-&gt;_Color = _Red;
                    _Lrotate(_Pnode-&gt;_Parent-&gt;_Parent);</span>
                }
            }
<span style = "background-color:#fdd">        }</span>

<span style = "background-color:#fdd">        _Head-&gt;_Parent-&gt;_Color = _Black; // root is always black
        return _Newnode;
    }</span>

<span style = "background-color:#fdd">    void _Orphan_ptr(const _Nodeptr _Ptr) noexcept {</span>
#if _ITERATOR_DEBUG_LEVEL == 2
<span style = "background-color:#fdd">        _Lockit _Lock(_LOCK_DEBUG);
        _Iterator_base12** _Pnext = &amp;this-&gt;_Myproxy-&gt;_Myfirstiter;
        while (*_Pnext) {
            const auto _Pnextptr = static_cast&lt;const_iterator&amp;&gt;(**_Pnext)._Ptr;
            if (_Pnextptr == _Myhead || (_Ptr != nullptr &amp;&amp; _Pnextptr != _Ptr)) {
                _Pnext = &amp;(*_Pnext)-&gt;_Mynextiter;
            } else { // orphan the iterator
                (*_Pnext)-&gt;_Myproxy = nullptr;
                *_Pnext             = (*_Pnext)-&gt;_Mynextiter;</span>
            }
<span style = "background-color:#fdd">        }</span>
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
        (void) _Ptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
<span style = "background-color:#fdd">    }</span>

    template &lt;class _Alnode&gt;
<span style = "background-color:#fdd">    void _Erase_tree_and_orphan(_Alnode&amp; _Al, _Nodeptr _Rootnode) noexcept {
        while (!_Rootnode-&gt;_Isnil) { // free subtrees, then node
            _Erase_tree_and_orphan(_Al, _Rootnode-&gt;_Right);
            auto _To_delete = _STD exchange(_Rootnode, _Rootnode-&gt;_Left);
            _Orphan_ptr(_To_delete);
            _Alnode::value_type::_Freenode(_Al, _To_delete);
        }
    }</span>

    template &lt;class _Alnode&gt;
<span style = "background-color:#dfd">    void _Erase_tree(_Alnode&amp; _Al, _Nodeptr _Rootnode) noexcept {
        while (!_Rootnode-&gt;_Isnil) { // free subtrees, then node</span>
<span style = "background-color:#fdd">            _Erase_tree(_Al, _Rootnode-&gt;_Right);
            _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode-&gt;_Left));
        }</span>
<span style = "background-color:#dfd">    }</span>

    template &lt;class _Alnode&gt;
<span style = "background-color:#dfd">    void _Erase_head(_Alnode&amp; _Al) noexcept {
        this-&gt;_Orphan_all();
        _Erase_tree(_Al, _Myhead-&gt;_Parent);
        _Alnode::value_type::_Freenode0(_Al, _Myhead);
    }</span>

    _Nodeptr _Myhead; // pointer to head node
    size_type _Mysize; // number of elements
};

template &lt;class _Alnode, class _Scary_val&gt;
struct _Tree_head_scoped_ptr { // temporary storage for allocated node pointers to ensure exception safety
    _Alnode&amp; _Al;
    _Scary_val* _Mycont;

<span style = "background-color:#fdd">    _Tree_head_scoped_ptr(_Alnode&amp; _Al_, _Scary_val&amp; _Mycont_) : _Al(_Al_), _Mycont(_STD addressof(_Mycont_)) {
        _Mycont-&gt;_Myhead = _Alnode::value_type::_Buyheadnode(_Al);
    }</span>

<span style = "background-color:#fdd">    void _Release() noexcept {
        _Mycont = nullptr;
    }</span>

<span style = "background-color:#fdd">    ~_Tree_head_scoped_ptr() {
        if (_Mycont) {
            _Mycont-&gt;_Erase_head(_Al);</span>
        }
<span style = "background-color:#fdd">    }</span>
};

template &lt;class _Alnode&gt;
struct _Tree_temp_node_alloc : _Alloc_construct_ptr&lt;_Alnode&gt; {
    // EH helper for _Tree_temp_node
<span style = "background-color:#fdd">    explicit _Tree_temp_node_alloc(_Alnode&amp; _Al_) : _Alloc_construct_ptr&lt;_Alnode&gt;(_Al_) {
        _Alloc_construct_ptr&lt;_Alnode&gt;::_Allocate();
    }</span>

    _Tree_temp_node_alloc(const _Tree_temp_node_alloc&amp;)            = delete;
    _Tree_temp_node_alloc&amp; operator=(const _Tree_temp_node_alloc&amp;) = delete;
};

template &lt;class _Alnode&gt;
struct _Tree_temp_node : _Tree_temp_node_alloc&lt;_Alnode&gt; {
    // temporarily stores a constructed tree node
    using _Alnode_traits = allocator_traits&lt;_Alnode&gt;;
    using _Nodeptr       = typename _Alnode_traits::pointer;

    enum _Redbl { // colors for link to parent
        _Red,
        _Black
    };

    template &lt;class... _Valtys&gt;
    explicit _Tree_temp_node(_Alnode&amp; _Al_, _Nodeptr _Myhead, _Valtys&amp;&amp;... _Vals)
<span style = "background-color:#fdd">        : _Tree_temp_node_alloc&lt;_Alnode&gt;(_Al_) {
        _Alnode_traits::construct(this-&gt;_Al, _STD addressof(this-&gt;_Ptr-&gt;_Myval), _STD forward&lt;_Valtys&gt;(_Vals)...);
        _Construct_in_place(this-&gt;_Ptr-&gt;_Left, _Myhead);
        _Construct_in_place(this-&gt;_Ptr-&gt;_Parent, _Myhead);
        _Construct_in_place(this-&gt;_Ptr-&gt;_Right, _Myhead);
        this-&gt;_Ptr-&gt;_Color = _Red;
        this-&gt;_Ptr-&gt;_Isnil = false;
    }</span>

    _Tree_temp_node(const _Tree_temp_node&amp;)            = delete;
    _Tree_temp_node&amp; operator=(const _Tree_temp_node&amp;) = delete;

<span style = "background-color:#fdd">    ~_Tree_temp_node() {
        if (this-&gt;_Ptr) {
            _Destroy_in_place(this-&gt;_Ptr-&gt;_Left);
            _Destroy_in_place(this-&gt;_Ptr-&gt;_Parent);
            _Destroy_in_place(this-&gt;_Ptr-&gt;_Right);
            _Alnode_traits::destroy(this-&gt;_Al, _STD addressof(this-&gt;_Ptr-&gt;_Myval));</span>
        }
<span style = "background-color:#fdd">    }</span>
};

template &lt;class _Traits&gt;
class _Tree { // ordered red-black tree for map/multimap/set/multiset
public:
    using key_type       = typename _Traits::key_type;
    using value_type     = typename _Traits::value_type;
    using allocator_type = typename _Traits::allocator_type;

protected:
    using _Alty          = _Rebind_alloc_t&lt;allocator_type, value_type&gt;;
    using _Alty_traits   = allocator_traits&lt;_Alty&gt;;
    using _Node          = _Tree_node&lt;value_type, typename _Alty_traits::void_pointer&gt;;
    using _Alnode        = _Rebind_alloc_t&lt;allocator_type, _Node&gt;;
    using _Alnode_traits = allocator_traits&lt;_Alnode&gt;;
    using _Nodeptr       = typename _Alnode_traits::pointer;

    using _Scary_val = _Tree_val&lt;conditional_t&lt;_Is_simple_alloc_v&lt;_Alnode&gt;, _Tree_simple_types&lt;value_type&gt;,
        _Tree_iter_types&lt;value_type, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Nodeptr&gt;&gt;&gt;;

    static constexpr bool _Multi  = _Traits::_Multi;
    static constexpr bool _Is_set = is_same_v&lt;key_type, value_type&gt;;

    enum _Redbl { // colors for link to parent
        _Red,
        _Black
    };

public:
    using value_compare = typename _Traits::value_compare;

    using key_compare = typename _Traits::key_compare;

    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = value_type&amp;;
    using const_reference = const value_type&amp;;

    using iterator       = conditional_t&lt;_Is_set, _Tree_const_iterator&lt;_Scary_val&gt;, _Tree_iterator&lt;_Scary_val&gt;&gt;;
    using const_iterator = _Tree_const_iterator&lt;_Scary_val&gt;;
    using _Unchecked_iterator =
        conditional_t&lt;_Is_set, _Tree_unchecked_const_iterator&lt;_Scary_val&gt;, _Tree_unchecked_iterator&lt;_Scary_val&gt;&gt;;
    using _Unchecked_const_iterator = _Tree_unchecked_const_iterator&lt;_Scary_val&gt;;

    using reverse_iterator       = _STD reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = _STD reverse_iterator&lt;const_iterator&gt;;

    enum class _Strategy : bool {
        _Copy,
        _Move,
    };

<span style = "background-color:#dfd">    _Tree(const key_compare&amp; _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {
        _Alloc_sentinel_and_proxy();
    }</span>

    _Tree(const key_compare&amp; _Parg, const allocator_type&amp; _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Parg, _One_then_variadic_args_t{}, _Al) {
        _Alloc_sentinel_and_proxy();
    }

    template &lt;class _Any_alloc&gt;
    _Tree(const _Tree&amp; _Right, _Any_alloc&amp;&amp; _Al)
<span style = "background-color:#fdd">        : _Mypair(_One_then_variadic_args_t{}, _Right.key_comp(), _One_then_variadic_args_t{},</span>
              _STD forward&lt;_Any_alloc&gt;(_Al)) {
<span style = "background-color:#fdd">        auto&amp;&amp; _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
        const auto _Scary = _Get_scary();
        _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, *_Scary);
        _Tree_head_scoped_ptr&lt;_Alnode, _Scary_val&gt; _Sentinel(_Getal(), *_Scary);
        _Copy&lt;_Strategy::_Copy&gt;(_Right);
        _Sentinel._Release();
        _Proxy._Release();
    }</span>

    _Tree(_Tree&amp;&amp; _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Right.key_comp(), // intentionally copy comparator, see LWG-2227
              _One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
        _Alloc_sentinel_and_proxy();
        _Swap_val_excluding_comp(_Right);
    }

    _Tree(_Tree&amp;&amp; _Right, const allocator_type&amp; _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Right.key_comp(), // intentionally copy comparator, see LWG-2227
              _One_then_variadic_args_t{}, _Al) {
        if constexpr (!_Alnode_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                auto&amp;&amp; _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
                const auto _Scary = _Get_scary();
                _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, *_Scary);
                _Tree_head_scoped_ptr&lt;_Alnode, _Scary_val&gt; _Sentinel(_Getal(), *_Scary);
                _Copy&lt;_Strategy::_Move&gt;(_Right);
                _Sentinel._Release();
                _Proxy._Release();
                return;
            }
        }

        _Alloc_sentinel_and_proxy();
        _Swap_val_excluding_comp(_Right);
    }

    _Tree&amp; operator=(_Tree&amp;&amp; _Right)
        noexcept(_Alnode_traits::is_always_equal::value &amp;&amp; is_nothrow_move_assignable_v&lt;key_compare&gt;) {
        if (this == _STD addressof(_Right)) {
            return *this;
        }

        auto&amp; _Al                 = _Getal();
        auto&amp; _Right_al           = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v&lt;_Alnode&gt;;
        if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
            if (_Al != _Right_al) {
                clear();
                _Getcomp()            = _Right._Getcomp(); // intentionally copy comparator, see LWG-2227
                auto&amp;&amp; _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
                auto&amp;&amp; _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
                _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
                const auto _Scary       = _Get_scary();
                const auto _Right_scary = _Right._Get_scary();
                const auto _Newhead     = _STD exchange(_Right_scary-&gt;_Myhead, _Node::_Buyheadnode(_Right_al));
                const auto _Newsize     = _STD exchange(_Right_scary-&gt;_Mysize, size_type{0});
                _Scary-&gt;_Erase_head(_Al);
                _Pocma(_Al, _Right_al);
                _Scary-&gt;_Myhead = _Newhead;
                _Scary-&gt;_Mysize = _Newsize;
                _Proxy._Bind(_Alproxy, _Scary);
                _Scary-&gt;_Swap_proxy_and_iterators(*_Right_scary);
                return *this;
            }
        } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            if (_Al != _Right_al) {
                clear();
                _Getcomp() = _Right._Getcomp(); // intentionally copy comparator, see LWG-2227
                _Copy&lt;_Strategy::_Move&gt;(_Right);
                return *this;
            }
        }

        clear();
        _Getcomp() = _Right._Getcomp(); // intentionally copy comparator, see LWG-2227
        _Pocma(_Al, _Right_al);
        _Swap_val_excluding_comp(_Right);

        return *this;
    }

private:
    void _Swap_val_excluding_comp(_Tree&amp; _Right) { // swap contents (except comparator) with _Right, equal allocators
        using _STD swap;
        const auto _Scary       = _Get_scary();
        const auto _Right_scary = _Right._Get_scary();
        _Scary-&gt;_Swap_proxy_and_iterators(*_Right_scary);
        swap(_Scary-&gt;_Myhead, _Right_scary-&gt;_Myhead); // intentional ADL
        _STD swap(_Scary-&gt;_Mysize, _Right_scary-&gt;_Mysize);
    }

protected:
    template &lt;class... _Valtys&gt;
    pair&lt;_Nodeptr, bool&gt; _Emplace(_Valtys&amp;&amp;... _Vals) {
        using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor&lt;_Valtys...&gt;;
        const auto _Scary             = _Get_scary();
        _Tree_find_result&lt;_Nodeptr&gt; _Loc;
        _Nodeptr _Inserted;
        if constexpr (!_Multi &amp;&amp; _In_place_key_extractor::_Extractable) {
            const auto&amp; _Keyval = _In_place_key_extractor::_Extract(_Vals...);
            _Loc                = _Find_lower_bound(_Keyval);
            if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
                return {_Loc._Bound, false};
            }

            _Check_grow_by_1();
            _Inserted = _Tree_temp_node&lt;_Alnode&gt;(_Getal(), _Scary-&gt;_Myhead, _STD forward&lt;_Valtys&gt;(_Vals)...)._Release();
            // nothrow hereafter
        } else {
            _Tree_temp_node&lt;_Alnode&gt; _Newnode(_Getal(), _Scary-&gt;_Myhead, _STD forward&lt;_Valtys&gt;(_Vals)...);
            const auto&amp; _Keyval = _Traits::_Kfn(_Newnode._Ptr-&gt;_Myval);
            if constexpr (_Multi) { // duplicate check if unique
                _Loc = _Find_upper_bound(_Keyval);
            } else {
                _Loc = _Find_lower_bound(_Keyval);
                if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
                    return {_Loc._Bound, false};
                }
            }

            _Check_grow_by_1();
            // nothrow hereafter
            _Inserted = _Newnode._Release();
        }

        return {_Scary-&gt;_Insert_node(_Loc._Location, _Inserted), true};
    }

public:
    template &lt;class... _Valtys&gt;
    pair&lt;iterator, bool&gt; emplace(_Valtys&amp;&amp;... _Vals) {
        const auto _Result = _Emplace(_STD forward&lt;_Valtys&gt;(_Vals)...);
        return {iterator(_Result.first, _Get_scary()), _Result.second};
    }

protected:
    template &lt;class... _Valtys&gt;
    _Nodeptr _Emplace_hint(const _Nodeptr _Hint, _Valtys&amp;&amp;... _Vals) {
        using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor&lt;_Valtys...&gt;;
        const auto _Scary             = _Get_scary();
        _Tree_find_hint_result&lt;_Nodeptr&gt; _Loc;
        _Nodeptr _Inserted;
        if constexpr (!_Multi &amp;&amp; _In_place_key_extractor::_Extractable) {
            _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));
            if (_Loc._Duplicate) {
                return _Loc._Location._Parent;
            }

            _Check_grow_by_1();
            _Inserted = _Tree_temp_node&lt;_Alnode&gt;(_Getal(), _Scary-&gt;_Myhead, _STD forward&lt;_Valtys&gt;(_Vals)...)._Release();
            // nothrow hereafter
        } else {
            _Tree_temp_node&lt;_Alnode&gt; _Newnode(_Getal(), _Scary-&gt;_Myhead, _STD forward&lt;_Valtys&gt;(_Vals)...);
            _Loc = _Find_hint(_Hint, _Traits::_Kfn(_Newnode._Ptr-&gt;_Myval));
            if constexpr (!_Multi) {
                if (_Loc._Duplicate) {
                    return _Loc._Location._Parent;
                }
            }

            _Check_grow_by_1();
            // nothrow hereafter
            _Inserted = _Newnode._Release();
        }

        return _Scary-&gt;_Insert_node(_Loc._Location, _Inserted);
    }

public:
    template &lt;class... _Valtys&gt;
    iterator emplace_hint(const_iterator _Where, _Valtys&amp;&amp;... _Vals) { // insert value_type(_Val...) at _Where
        const auto _Scary = _Get_scary();
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Where._Getcont() == _Scary, "map/set insert iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2
        return iterator(_Emplace_hint(_Where._Ptr, _STD forward&lt;_Valtys&gt;(_Vals)...), _Scary);
    }

<span style = "background-color:#dfd">    ~_Tree() noexcept {
        const auto _Scary = _Get_scary();
        _Scary-&gt;_Erase_head(_Getal());</span>
#if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
<span style = "background-color:#dfd">        auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
        _Delete_plain_internal(_Alproxy, _Scary-&gt;_Myproxy);</span>
#endif // _ITERATOR_DEBUG_LEVEL != 0
<span style = "background-color:#dfd">    }</span>

public:
    _Tree&amp; operator=(const _Tree&amp; _Right) {
        if (this == _STD addressof(_Right)) {
            return *this;
        }

        auto&amp; _Al       = _Getal();
        auto&amp; _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v&lt;_Alnode&gt;) {
            if (_Al != _Right_al) {
                clear();
                const auto _Scary = _Get_scary();
                _Scary-&gt;_Orphan_all();
                auto&amp;&amp; _Alproxy       = _GET_PROXY_ALLOCATOR(_Alnode, _Al);
                auto&amp;&amp; _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Right_al);
                _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
                auto _Right_al_non_const = _Right_al;
                auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
                _Node::_Freenode0(_Al, _Scary-&gt;_Myhead);
                _Pocca(_Al, _Right_al);
                _Scary-&gt;_Myhead = _Newhead;
                _Proxy._Bind(_Alproxy, _Scary);
                _Getcomp() = _Right._Getcomp();
                _Copy&lt;_Strategy::_Copy&gt;(_Right);
                return *this;
            }
        }

        clear();
        _Getcomp() = _Right._Getcomp();
        _Pocca(_Al, _Right_al);
        _Copy&lt;_Strategy::_Copy&gt;(_Right);

        return *this;
    }

    _NODISCARD iterator begin() noexcept {
        const auto _Scary = _Get_scary();
        return iterator(_Scary-&gt;_Myhead-&gt;_Left, _Scary);
    }

    _NODISCARD const_iterator begin() const noexcept {
        const auto _Scary = _Get_scary();
        return const_iterator(_Scary-&gt;_Myhead-&gt;_Left, _Scary);
    }

    _NODISCARD iterator end() noexcept {
        const auto _Scary = _Get_scary();
        return iterator(_Scary-&gt;_Myhead, _Scary);
    }

    _NODISCARD const_iterator end() const noexcept {
        const auto _Scary = _Get_scary();
        return const_iterator(_Scary-&gt;_Myhead, _Scary);
    }

<span style = "background-color:#fdd">    _Unchecked_iterator _Unchecked_begin() noexcept {
        return _Unchecked_iterator(_Get_scary()-&gt;_Myhead-&gt;_Left, nullptr);
    }</span>

    _Unchecked_const_iterator _Unchecked_begin() const noexcept {
        return _Unchecked_const_iterator(_Get_scary()-&gt;_Myhead-&gt;_Left, nullptr);
    }

<span style = "background-color:#fdd">    _Default_sentinel _Unchecked_end() const noexcept {
        return {};
    }</span>

    _Unchecked_const_iterator _Unchecked_end_iter() const noexcept {
        return _Unchecked_const_iterator(_Get_scary()-&gt;_Myhead, nullptr);
    }

    _NODISCARD reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    _NODISCARD const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    _NODISCARD reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    _NODISCARD const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    _NODISCARD const_iterator cbegin() const noexcept {
        return begin();
    }

    _NODISCARD const_iterator cend() const noexcept {
        return end();
    }

    _NODISCARD const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    _NODISCARD const_reverse_iterator crend() const noexcept {
        return rend();
    }

    _NODISCARD size_type size() const noexcept {
        return _Get_scary()-&gt;_Mysize;
    }

<span style = "background-color:#fdd">    _NODISCARD size_type max_size() const noexcept {
        return (_STD min)(</span>
            static_cast&lt;size_type&gt;(_STD _Max_limit&lt;difference_type&gt;()), _Alnode_traits::max_size(_Getal()));
<span style = "background-color:#fdd">    }</span>

    _NODISCARD_EMPTY_MEMBER bool empty() const noexcept {
        return _Get_scary()-&gt;_Mysize == 0;
    }

    _NODISCARD allocator_type get_allocator() const noexcept {
        return static_cast&lt;allocator_type&gt;(_Getal());
    }

<span style = "background-color:#fdd">    _NODISCARD key_compare key_comp() const {
        return _Getcomp();
    }</span>

    _NODISCARD value_compare value_comp() const {
        return value_compare(key_comp());
    }

    template &lt;bool _Multi2 = _Multi, enable_if_t&lt;!_Multi2, int&gt; = 0&gt;
    pair&lt;iterator, bool&gt; insert(const value_type&amp; _Val) {
        const auto _Result = _Emplace(_Val);
        return {iterator(_Result.first, _Get_scary()), _Result.second};
    }

    template &lt;bool _Multi2 = _Multi, enable_if_t&lt;_Multi2, int&gt; = 0&gt;
    iterator insert(const value_type&amp; _Val) {
        return iterator(_Emplace(_Val).first, _Get_scary());
    }

    template &lt;bool _Multi2 = _Multi, enable_if_t&lt;!_Multi2, int&gt; = 0&gt;
    pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; _Val) {
        const auto _Result = _Emplace(_STD move(_Val));
        return {iterator(_Result.first, _Get_scary()), _Result.second};
    }

    template &lt;bool _Multi2 = _Multi, enable_if_t&lt;_Multi2, int&gt; = 0&gt;
    iterator insert(value_type&amp;&amp; _Val) {
        return iterator(_Emplace(_STD move(_Val)).first, _Get_scary());
    }

    iterator insert(const_iterator _Where, const value_type&amp; _Val) {
        const auto _Scary = _Get_scary();
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Where._Getcont() == _Scary, "map/set insert iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2
        return iterator(_Emplace_hint(_Where._Ptr, _Val), _Scary);
    }

    iterator insert(const_iterator _Where, value_type&amp;&amp; _Val) {
        const auto _Scary = _Get_scary();
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Where._Getcont() == _Scary, "map/set insert iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2
        return iterator(_Emplace_hint(_Where._Ptr, _STD move(_Val)), _Scary);
    }

protected:
    template &lt;class _Iter, class _Sent&gt;
    void _Insert_range_unchecked(_Iter _First, const _Sent _Last) {
        const auto _Myhead = _Get_scary()-&gt;_Myhead;
        for (; _First != _Last; ++_First) {
            _Emplace_hint(_Myhead, *_First);
        }
    }

public:
    template &lt;class _Iter&gt;
    void insert(_Iter _First, _Iter _Last) {
        _STD _Adl_verify_range(_First, _Last);
        _Insert_range_unchecked(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last));
    }

#if _HAS_CXX23
    template &lt;_Container_compatible_range&lt;value_type&gt; _Rng&gt;
    void insert_range(_Rng&amp;&amp; _Range) {
        _Insert_range_unchecked(_RANGES _Ubegin(_Range), _RANGES _Uend(_Range));
    }
#endif // _HAS_CXX23

    void insert(initializer_list&lt;value_type&gt; _Ilist) {
        _Insert_range_unchecked(_Ilist.begin(), _Ilist.end());
    }

private:
    _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _Where) noexcept {
        const auto _Scary                    = _Get_scary();
        _Unchecked_const_iterator _Successor = _Where;
        ++_Successor; // save successor iterator for return
        _Nodeptr _Erasednode = _Scary-&gt;_Extract(_Where); // node to erase
        _Scary-&gt;_Orphan_ptr(_Erasednode);
        _Node::_Freenode(_Getal(), _Erasednode); // delete erased node
        return _Successor._Ptr; // return successor nodeptr
    }

    _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _First, _Unchecked_const_iterator _Last) noexcept {
        const auto _Begin = _Unchecked_begin();
        if (_First == _Begin &amp;&amp; _Last._Ptr-&gt;_Isnil) {
            // erase all
            clear();
            return _Last._Ptr;
        }

        // partial erase, one at a time
        while (_First != _Last) {
            _Erase_unchecked(_First++);
        }

        return _Last._Ptr;
    }

    size_type _Erase(const pair&lt;_Nodeptr, _Nodeptr&gt; _Where) noexcept {
        const _Unchecked_const_iterator _First(_Where.first, nullptr);
        const _Unchecked_const_iterator _Last(_Where.second, nullptr);
        const auto _Num = static_cast&lt;size_type&gt;(_STD distance(_First, _Last));
        _Erase_unchecked(_First, _Last);
        return _Num;
    }

public:
    template &lt;class _Iter = iterator, enable_if_t&lt;!is_same_v&lt;_Iter, const_iterator&gt;, int&gt; = 0&gt;
    iterator erase(iterator _Where) noexcept /* strengthened */ {
        const auto _Scary = _Get_scary();
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Where._Getcont() == _Scary, "map/set erase iterator from incorrect container");
        _STL_VERIFY(!_Where._Ptr-&gt;_Isnil, "cannot erase map/set end() iterator");
#endif // _ITERATOR_DEBUG_LEVEL == 2
        return iterator(_Erase_unchecked(_Where._Unwrapped()), _Scary);
    }

    iterator erase(const_iterator _Where) noexcept /* strengthened */ {
        const auto _Scary = _Get_scary();
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Where._Getcont() == _Scary, "map/set erase iterator from incorrect container");
        _STL_VERIFY(!_Where._Ptr-&gt;_Isnil, "cannot erase map/set end() iterator");
#endif // _ITERATOR_DEBUG_LEVEL == 2
        return iterator(_Erase_unchecked(_Where._Unwrapped()), _Scary);
    }

    iterator erase(const_iterator _First, const_iterator _Last) noexcept /* strengthened */ {
        return iterator(_Erase_unchecked(_First._Unwrapped(), _Last._Unwrapped()), _Get_scary());
    }

    size_type erase(const key_type&amp; _Keyval) noexcept(noexcept(_Eqrange(_Keyval))) /* strengthened */ {
        return _Erase(_Eqrange(_Keyval));
    }

#if _HAS_CXX23
    template &lt;class _Kx&gt;
        requires _Is_transparent_v&lt;key_compare&gt; &amp;&amp; (!is_convertible_v&lt;_Kx, const_iterator&gt;)
              &amp;&amp; (!is_convertible_v&lt;_Kx, iterator&gt;)
    size_type erase(_Kx&amp;&amp; _Keyval) noexcept(noexcept(_Eqrange(_Keyval))) /* strengthened */ {
        return _Erase(_Eqrange(_Keyval));
    }
#endif // _HAS_CXX23

    void clear() noexcept {
        const auto _Scary = _Get_scary();
        _Scary-&gt;_Orphan_ptr(nullptr);
        auto _Head = _Scary-&gt;_Myhead;
        _Scary-&gt;_Erase_tree(_Getal(), _Head-&gt;_Parent);
        _Head-&gt;_Parent  = _Head;
        _Head-&gt;_Left    = _Head;
        _Head-&gt;_Right   = _Head;
        _Scary-&gt;_Mysize = 0;
    }

private:
    template &lt;class _Other&gt;
    _NODISCARD _Nodeptr _Find(const _Other&amp; _Keyval) const {
        const _Tree_find_result&lt;_Nodeptr&gt; _Loc = _Find_lower_bound(_Keyval);
        if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
            return _Loc._Bound;
        }

        return _Get_scary()-&gt;_Myhead;
    }

public:
    _NODISCARD iterator find(const key_type&amp; _Keyval) {
        return iterator(_Find(_Keyval), _Get_scary());
    }

    _NODISCARD const_iterator find(const key_type&amp; _Keyval) const {
        return const_iterator(_Find(_Keyval), _Get_scary());
    }

    template &lt;class _Other, class _Mycomp = key_compare, enable_if_t&lt;_Is_transparent_v&lt;_Mycomp&gt;, int&gt; = 0&gt;
    _NODISCARD iterator find(const _Other&amp; _Keyval) {
        return iterator(_Find(_Keyval), _Get_scary());
    }

    template &lt;class _Other, class _Mycomp = key_compare, enable_if_t&lt;_Is_transparent_v&lt;_Mycomp&gt;, int&gt; = 0&gt;
    _NODISCARD const_iterator find(const _Other&amp; _Keyval) const {
        return const_iterator(_Find(_Keyval), _Get_scary());
    }

#if _HAS_CXX20
    _NODISCARD bool contains(const key_type&amp; _Keyval) const {
        return _Lower_bound_duplicate(_Find_lower_bound(_Keyval)._Bound, _Keyval);
    }

    template &lt;class _Other&gt;
        requires _Is_transparent_v&lt;key_compare&gt;
    _NODISCARD bool contains(const _Other&amp; _Keyval) const {
        return _Lower_bound_duplicate(_Find_lower_bound(_Keyval)._Bound, _Keyval);
    }
#endif // _HAS_CXX20

    _NODISCARD size_type count(const key_type&amp; _Keyval) const {
        if constexpr (_Multi) {
            const auto _Ans = _Eqrange(_Keyval);
            return static_cast&lt;size_type&gt;(_STD distance(
                _Unchecked_const_iterator(_Ans.first, nullptr), _Unchecked_const_iterator(_Ans.second, nullptr)));
        } else {
            return _Lower_bound_duplicate(_Find_lower_bound(_Keyval)._Bound, _Keyval);
        }
    }

    template &lt;class _Other, class _Mycomp = key_compare, enable_if_t&lt;_Is_transparent_v&lt;_Mycomp&gt;, int&gt; = 0&gt;
    _NODISCARD size_type count(const _Other&amp; _Keyval) const {
        const auto _Ans = _Eqrange(_Keyval);
        return static_cast&lt;size_type&gt;(_STD distance(
            _Unchecked_const_iterator(_Ans.first, nullptr), _Unchecked_const_iterator(_Ans.second, nullptr)));
    }

    _NODISCARD iterator lower_bound(const key_type&amp; _Keyval) {
        return iterator(_Find_lower_bound(_Keyval)._Bound, _Get_scary());
    }

    _NODISCARD const_iterator lower_bound(const key_type&amp; _Keyval) const {
        return const_iterator(_Find_lower_bound(_Keyval)._Bound, _Get_scary());
    }

    template &lt;class _Other, class _Mycomp = key_compare, enable_if_t&lt;_Is_transparent_v&lt;_Mycomp&gt;, int&gt; = 0&gt;
    _NODISCARD iterator lower_bound(const _Other&amp; _Keyval) {
        return iterator(_Find_lower_bound(_Keyval)._Bound, _Get_scary());
    }

    template &lt;class _Other, class _Mycomp = key_compare, enable_if_t&lt;_Is_transparent_v&lt;_Mycomp&gt;, int&gt; = 0&gt;
    _NODISCARD const_iterator lower_bound(const _Other&amp; _Keyval) const {
        return const_iterator(_Find_lower_bound(_Keyval)._Bound, _Get_scary());
    }

    _NODISCARD iterator upper_bound(const key_type&amp; _Keyval) {
        return iterator(_Find_upper_bound(_Keyval)._Bound, _Get_scary());
    }

    _NODISCARD const_iterator upper_bound(const key_type&amp; _Keyval) const {
        return const_iterator(_Find_upper_bound(_Keyval)._Bound, _Get_scary());
    }

    template &lt;class _Other, class _Mycomp = key_compare, enable_if_t&lt;_Is_transparent_v&lt;_Mycomp&gt;, int&gt; = 0&gt;
    _NODISCARD iterator upper_bound(const _Other&amp; _Keyval) {
        return iterator(_Find_upper_bound(_Keyval)._Bound, _Get_scary());
    }

    template &lt;class _Other, class _Mycomp = key_compare, enable_if_t&lt;_Is_transparent_v&lt;_Mycomp&gt;, int&gt; = 0&gt;
    _NODISCARD const_iterator upper_bound(const _Other&amp; _Keyval) const {
        return const_iterator(_Find_upper_bound(_Keyval)._Bound, _Get_scary());
    }

    _NODISCARD pair&lt;iterator, iterator&gt; equal_range(const key_type&amp; _Keyval) {
        const auto _Result = _Eqrange(_Keyval);
        const auto _Scary  = _Get_scary();
        return {iterator(_Result.first, _Scary), iterator(_Result.second, _Scary)};
    }

    _NODISCARD pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; _Keyval) const {
        const auto _Result = _Eqrange(_Keyval);
        const auto _Scary  = _Get_scary();
        return {const_iterator(_Result.first, _Scary), const_iterator(_Result.second, _Scary)};
    }

    template &lt;class _Other, class _Mycomp = key_compare, enable_if_t&lt;_Is_transparent_v&lt;_Mycomp&gt;, int&gt; = 0&gt;
    _NODISCARD pair&lt;iterator, iterator&gt; equal_range(const _Other&amp; _Keyval) {
        const auto _Result = _Eqrange(_Keyval);
        const auto _Scary  = _Get_scary();
        return {iterator(_Result.first, _Scary), iterator(_Result.second, _Scary)};
    }

    template &lt;class _Other, class _Mycomp = key_compare, enable_if_t&lt;_Is_transparent_v&lt;_Mycomp&gt;, int&gt; = 0&gt;
    _NODISCARD pair&lt;const_iterator, const_iterator&gt; equal_range(const _Other&amp; _Keyval) const {
        const auto _Result = _Eqrange(_Keyval);
        const auto _Scary  = _Get_scary();
        return {const_iterator(_Result.first, _Scary), const_iterator(_Result.second, _Scary)};
    }

    void swap(_Tree&amp; _Right) noexcept(_Is_nothrow_swappable&lt;key_compare&gt;::value) /* strengthened */ {
        using _STD swap;
        if (this != _STD addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            _Swap_val_excluding_comp(_Right);
            swap(_Getcomp(), _Right._Getcomp()); // intentional ADL
        }
    }

protected:
    template &lt;class _Keyty&gt;
    _Tree_find_hint_result&lt;_Nodeptr&gt; _Find_hint(const _Nodeptr _Hint, const _Keyty&amp; _Keyval) const {
        const auto&amp; _Comp = _Getcomp();
        const auto _Head  = _Get_scary()-&gt;_Myhead;
        if constexpr (_Multi) { // insert even if duplicate
            if (_Hint-&gt;_Isnil) {
                // insert at end if greater than or equal to last element
                if (_Head-&gt;_Parent-&gt;_Isnil || !_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Head-&gt;_Right-&gt;_Myval))) {
                    return {{_Head-&gt;_Right, _Tree_child::_Right}, false};
                }

                // _Hint is end(); it must be closer to the end of equivalents
                return {_Find_upper_bound(_Keyval)._Location, false};
            }

            if (_Hint == _Head-&gt;_Left) {
                // insert at beginning if less than or equal to first element
                if (!_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint-&gt;_Myval), _Keyval)) {
                    return {{_Hint, _Tree_child::_Left}, false};
                }

                // _Hint is begin(); it must be closer to the beginning of equivalents
                return {_Find_lower_bound(_Keyval)._Location, false};
            }

            if (!_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint-&gt;_Myval), _Keyval)) {
                // _Val &lt;= *_Hint
                const auto _Prev = (--(_Unchecked_const_iterator(_Hint, nullptr)))._Ptr;
                if (!_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Prev-&gt;_Myval))) {
                    // _Val &lt;= *_Hint and _Val &gt;= *prev(_Hint); insert here
                    if (_Prev-&gt;_Right-&gt;_Isnil) {
                        return {{_Prev, _Tree_child::_Right}, false};
                    } else {
                        return {{_Hint, _Tree_child::_Left}, false};
                    }
                }

                // _Val goes before *_Hint; _Hint must be closer to the end of equivalents
                return {_Find_upper_bound(_Keyval)._Location, false};
            }

            // _Val goes after *_Hint; _Hint must be closer to the beginning of equivalents
            return {_Find_lower_bound(_Keyval)._Location, false};
        } else { // insert only if unique
            if (_Hint-&gt;_Isnil) { // insert at end if after last element
                // insert at end if greater than last element
                if (_Head-&gt;_Parent-&gt;_Isnil || _DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Head-&gt;_Right-&gt;_Myval), _Keyval)) {
                    return {{_Head-&gt;_Right, _Tree_child::_Right}, false};
                }
            } else if (_Hint == _Head-&gt;_Left) {
                // insert at beginning if less than first element
                if (_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Hint-&gt;_Myval))) {
                    return {{_Hint, _Tree_child::_Left}, false};
                }
            } else if (_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Hint-&gt;_Myval))) {
                // _Val &lt; *_Hint
                const auto _Prev = (--(_Unchecked_const_iterator(_Hint, nullptr)))._Ptr;
                if (_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Prev-&gt;_Myval), _Keyval)) {
                    // _Val &lt; *_Hint and _Val &gt; *prev(_Hint); insert here
                    if (_Prev-&gt;_Right-&gt;_Isnil) {
                        return {{_Prev, _Tree_child::_Right}, false};
                    } else {
                        return {{_Hint, _Tree_child::_Left}, false};
                    }
                }
            } else if (_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint-&gt;_Myval), _Keyval)) {
                // _Val &gt; *_Hint
                const auto _Next = (++(_Unchecked_const_iterator(_Hint, nullptr)))._Ptr;
                if (_Next-&gt;_Isnil || _DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Next-&gt;_Myval))) {
                    // _Val &gt; *_Hint and _Val &lt; *next(_Hint); insert here
                    if (_Hint-&gt;_Right-&gt;_Isnil) {
                        return {{_Hint, _Tree_child::_Right}, false};
                    }

                    return {{_Next, _Tree_child::_Left}, false};
                }
            } else {
                // _Val is equivalent to *_Hint; don't insert
                return {{_Hint, _Tree_child::_Right}, true};
            }

            const auto _Loc = _Find_lower_bound(_Keyval);
            if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
                return {{_Loc._Bound, _Tree_child::_Unused}, true};
            }

            return {_Loc._Location, false};
        }
    }

    template &lt;class _Keyty&gt;
    _Tree_find_result&lt;_Nodeptr&gt; _Find_upper_bound(const _Keyty&amp; _Keyval) const {
        const auto _Scary = _Get_scary();
        _Tree_find_result&lt;_Nodeptr&gt; _Result{{_Scary-&gt;_Myhead-&gt;_Parent, _Tree_child::_Right}, _Scary-&gt;_Myhead};
        _Nodeptr _Trynode = _Result._Location._Parent;
        while (!_Trynode-&gt;_Isnil) {
            _Result._Location._Parent = _Trynode;
            if (_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Trynode-&gt;_Myval))) {
                _Result._Location._Child = _Tree_child::_Left;
                _Result._Bound           = _Trynode;
                _Trynode                 = _Trynode-&gt;_Left;
            } else {
                _Result._Location._Child = _Tree_child::_Right;
                _Trynode                 = _Trynode-&gt;_Right;
            }
        }

        return _Result;
    }

    template &lt;class _Keyty&gt;
<span style = "background-color:#fdd">    bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty&amp; _Keyval) const {
        return !_Bound-&gt;_Isnil &amp;&amp; !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound-&gt;_Myval));
    }</span>

    template &lt;class _Keyty&gt;
<span style = "background-color:#fdd">    _Tree_find_result&lt;_Nodeptr&gt; _Find_lower_bound(const _Keyty&amp; _Keyval) const {
        const auto _Scary = _Get_scary();
        _Tree_find_result&lt;_Nodeptr&gt; _Result{{_Scary-&gt;_Myhead-&gt;_Parent, _Tree_child::_Right}, _Scary-&gt;_Myhead};
        _Nodeptr _Trynode = _Result._Location._Parent;
        while (!_Trynode-&gt;_Isnil) {
            _Result._Location._Parent = _Trynode;
            if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode-&gt;_Myval), _Keyval)) {
                _Result._Location._Child = _Tree_child::_Right;
                _Trynode                 = _Trynode-&gt;_Right;
            } else {
                _Result._Location._Child = _Tree_child::_Left;
                _Result._Bound           = _Trynode;
                _Trynode                 = _Trynode-&gt;_Left;</span>
            }
<span style = "background-color:#fdd">        }</span>

<span style = "background-color:#fdd">        return _Result;
    }</span>

<span style = "background-color:#fdd">    void _Check_grow_by_1() {
        if (max_size() == _Get_scary()-&gt;_Mysize) {
            _Throw_tree_length_error();</span>
        }
<span style = "background-color:#fdd">    }</span>

    template &lt;_Strategy _Strat&gt;
<span style = "background-color:#fdd">    void _Copy(const _Tree&amp; _Right) { // copy or move entire tree from _Right
        const auto _Scary        = _Get_scary();
        const auto _Right_scary  = _Right._Get_scary();
        _Scary-&gt;_Myhead-&gt;_Parent = _Copy_nodes&lt;_Strat&gt;(_Right_scary-&gt;_Myhead-&gt;_Parent, _Scary-&gt;_Myhead);
        _Scary-&gt;_Mysize          = _Right_scary-&gt;_Mysize;
        if (!_Scary-&gt;_Myhead-&gt;_Parent-&gt;_Isnil) { // nonempty tree, look for new smallest and largest
            _Scary-&gt;_Myhead-&gt;_Left  = _Scary_val::_Min(_Scary-&gt;_Myhead-&gt;_Parent);
            _Scary-&gt;_Myhead-&gt;_Right = _Scary_val::_Max(_Scary-&gt;_Myhead-&gt;_Parent);
        } else { // empty tree, just tidy head pointers
            _Scary-&gt;_Myhead-&gt;_Left  = _Scary-&gt;_Myhead;
            _Scary-&gt;_Myhead-&gt;_Right = _Scary-&gt;_Myhead;</span>
        }
<span style = "background-color:#fdd">    }</span>

    template &lt;_Strategy _Strat, class _Ty&gt;
<span style = "background-color:#fdd">    _Nodeptr _Copy_or_move(_Ty&amp; _Val) {</span>
        if constexpr (_Strat == _Strategy::_Copy) {
<span style = "background-color:#fdd">            return _Buynode(_Val);</span>
        } else {
            if constexpr (_Is_set) {
                return _Buynode(_STD move(_Val));
            } else {
                return _Buynode(_STD move(const_cast&lt;key_type&amp;&gt;(_Val.first)), _STD move(_Val.second));
            }
        }
<span style = "background-color:#fdd">    }</span>

    template &lt;_Strategy _Strat&gt;
<span style = "background-color:#fdd">    _Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode) {</span>
        // copy entire subtree, recursively
<span style = "background-color:#fdd">        const auto _Scary = _Get_scary();
        _Nodeptr _Newroot = _Scary-&gt;_Myhead; // point at nil node</span>

<span style = "background-color:#fdd">        if (!_Rootnode-&gt;_Isnil) { // copy or move a node, then any subtrees
            _Newroot          = _Copy_or_move&lt;_Strat&gt;(_Rootnode-&gt;_Myval); // memorize new root
            _Newroot-&gt;_Parent = _Wherenode;
            _Newroot-&gt;_Color  = _Rootnode-&gt;_Color;</span>

<span style = "background-color:#fdd">            typename _Scary_val::template _Erase_tree_and_orphan_guard&lt;_Alnode&gt; _Guard{_Scary, _Getal(), _Newroot};</span>

<span style = "background-color:#fdd">            _Newroot-&gt;_Left  = _Copy_nodes&lt;_Strat&gt;(_Rootnode-&gt;_Left, _Newroot);
            _Newroot-&gt;_Right = _Copy_nodes&lt;_Strat&gt;(_Rootnode-&gt;_Right, _Newroot);</span>

<span style = "background-color:#fdd">            _Guard._Val_ptr = nullptr;
        }</span>

<span style = "background-color:#fdd">        return _Newroot; // return newly constructed tree
    }</span>

    template &lt;class _Other&gt;
    pair&lt;_Nodeptr, _Nodeptr&gt; _Eqrange(const _Other&amp; _Keyval) const
        noexcept(_Nothrow_compare&lt;key_compare, key_type, _Other&gt; &amp;&amp; _Nothrow_compare&lt;key_compare, _Other, key_type&gt;) {
        // find range of nodes equivalent to _Keyval
        const auto _Scary = _Get_scary();
        const auto&amp; _Comp = _Getcomp();
        _Nodeptr _Pnode   = _Scary-&gt;_Myhead-&gt;_Parent;
        _Nodeptr _Lonode  = _Scary-&gt;_Myhead; // end() if search fails
        _Nodeptr _Hinode  = _Scary-&gt;_Myhead; // end() if search fails

        while (!_Pnode-&gt;_Isnil) {
            const auto&amp; _Nodekey = _Traits::_Kfn(_Pnode-&gt;_Myval);
            if (_DEBUG_LT_PRED(_Comp, _Nodekey, _Keyval)) {
                _Pnode = _Pnode-&gt;_Right; // descend right subtree
            } else { // _Pnode not less than _Keyval, remember it
                if (_Hinode-&gt;_Isnil &amp;&amp; _DEBUG_LT_PRED(_Comp, _Keyval, _Nodekey)) {
                    _Hinode = _Pnode; // _Pnode greater, remember it
                }

                _Lonode = _Pnode;
                _Pnode  = _Pnode-&gt;_Left; // descend left subtree
            }
        }

        _Pnode = _Hinode-&gt;_Isnil ? _Scary-&gt;_Myhead-&gt;_Parent : _Hinode-&gt;_Left; // continue scan for upper bound
        while (!_Pnode-&gt;_Isnil) {
            if (_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Pnode-&gt;_Myval))) {
                // _Pnode greater than _Keyval, remember it
                _Hinode = _Pnode;
                _Pnode  = _Pnode-&gt;_Left; // descend left subtree
            } else {
                _Pnode = _Pnode-&gt;_Right; // descend right subtree
            }
        }

        return {_Lonode, _Hinode};
    }

#if _HAS_CXX17
public:
    using node_type = typename _Traits::node_type;

    node_type extract(const const_iterator _Where) {
        const auto _Scary = _Get_scary();
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Where._Getcont() == _Scary &amp;&amp; !_Where._Ptr-&gt;_Isnil, "map/set erase iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        const auto _Ptr = _Scary-&gt;_Extract(_Where._Unwrapped());
        _Scary-&gt;_Orphan_ptr(_Ptr);
        return node_type::_Make(_Ptr, _Getal());
    }

    node_type extract(const key_type&amp; _Keyval) {
        const const_iterator _Where = find(_Keyval);
        if (_Where == end()) {
            return node_type{};
        }

        return extract(_Where);
    }

#if _HAS_CXX23
    template &lt;class _Kx&gt;
        requires _Is_transparent_v&lt;key_compare&gt; &amp;&amp; (!is_convertible_v&lt;_Kx, const_iterator&gt;)
              &amp;&amp; (!is_convertible_v&lt;_Kx, iterator&gt;)
    node_type extract(_Kx&amp;&amp; _Keyval) {
        const const_iterator _Where = find(_Keyval);
        if (_Where == end()) {
            return node_type{};
        }

        return extract(_Where);
    }
#endif // _HAS_CXX23

    auto insert(node_type&amp;&amp; _Handle) {
        if (_Handle.empty()) {
            if constexpr (_Multi) {
                return end();
            } else {
                return _Insert_return_type&lt;iterator, node_type&gt;{end(), false, {}};
            }
        }

        _Check_node_allocator(_Handle);
        const auto _Scary        = _Get_scary();
        const auto _Attempt_node = _Handle._Getptr();
        const auto&amp; _Keyval      = _Traits::_Kfn(_Attempt_node-&gt;_Myval);
        _Tree_find_result&lt;_Nodeptr&gt; _Loc;
        if constexpr (_Multi) {
            _Loc = _Find_upper_bound(_Keyval);
        } else {
            _Loc = _Find_lower_bound(_Keyval);
            if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
                return _Insert_return_type&lt;iterator, node_type&gt;{
                    iterator(_Loc._Bound, _Scary), false, _STD move(_Handle)};
            }
        }

        _Check_grow_by_1();

        // nothrow hereafter

        _Attempt_node-&gt;_Left = _Scary-&gt;_Myhead;
        // _Attempt_node-&gt;_Parent handled in _Insert_node
        _Attempt_node-&gt;_Right = _Scary-&gt;_Myhead;
        _Attempt_node-&gt;_Color = _Red;

        const auto _Inserted = _Scary-&gt;_Insert_node(_Loc._Location, _Handle._Release());
        if constexpr (_Multi) {
            return iterator(_Inserted, _Scary);
        } else {
            return _Insert_return_type&lt;iterator, node_type&gt;{iterator(_Inserted, _Scary), true, _STD move(_Handle)};
        }
    }

    iterator insert(const const_iterator _Hint, node_type&amp;&amp; _Handle) {
        const auto _Scary = _Get_scary();
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Hint._Getcont() == _Scary, "map/set insert iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2
        if (_Handle.empty()) {
            return end();
        }

        _Check_node_allocator(_Handle);
        const auto _Attempt_node = _Handle._Getptr();
        const auto&amp; _Keyval      = _Traits::_Kfn(_Attempt_node-&gt;_Myval);
        const auto _Loc          = _Find_hint(_Hint._Ptr, _Keyval);
        if (_Loc._Duplicate) {
            return iterator(_Loc._Location._Parent, _Scary);
        }

        _Check_grow_by_1();

        _Attempt_node-&gt;_Left = _Scary-&gt;_Myhead;
        // _Attempt_node-&gt;_Parent handled in _Insert_node
        _Attempt_node-&gt;_Right = _Scary-&gt;_Myhead;
        _Attempt_node-&gt;_Color = _Red;

        return iterator(_Scary-&gt;_Insert_node(_Loc._Location, _Handle._Release()), _Scary);
    }

    template &lt;class&gt;
    friend class _Tree;

    template &lt;class _Other_traits&gt;
    void merge(_Tree&lt;_Other_traits&gt;&amp; _That) {
        static_assert(is_same_v&lt;_Nodeptr, typename _Tree&lt;_Other_traits&gt;::_Nodeptr&gt;,
            "merge() requires an argument with a compatible node type.");

        static_assert(is_same_v&lt;allocator_type, typename _Tree&lt;_Other_traits&gt;::allocator_type&gt;,
            "merge() requires an argument with the same allocator type.");

        if constexpr (is_same_v&lt;_Tree, _Tree&lt;_Other_traits&gt;&gt;) {
            if (this == _STD addressof(_That)) {
                return;
            }
        }

#if _ITERATOR_DEBUG_LEVEL == 2
        if constexpr (!_Alnode_traits::is_always_equal::value) {
            _STL_VERIFY(_Getal() == _That._Getal(), "allocator incompatible for merge");
        }
#endif // _ITERATOR_DEBUG_LEVEL == 2

        const auto _Scary      = _Get_scary();
        const auto _Head       = _Scary-&gt;_Myhead;
        const auto _That_scary = _That._Get_scary();
        auto _First            = _That._Unchecked_begin();
        while (!_First._Ptr-&gt;_Isnil) {
            const auto _Attempt_node = _First._Ptr;
            ++_First;
            _Tree_find_result&lt;_Nodeptr&gt; _Loc;
            const auto&amp; _Keyval = _Traits::_Kfn(_Attempt_node-&gt;_Myval);
            if constexpr (_Multi) {
                _Loc = _Find_upper_bound(_Keyval);
            } else {
                _Loc = _Find_lower_bound(_Keyval);
                if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
                    continue;
                }
            }

            _Check_grow_by_1();

            // nothrow hereafter for this iteration
            const auto _Extracted = _That_scary-&gt;_Extract(_Unchecked_const_iterator(_Attempt_node, nullptr));
            _Extracted-&gt;_Left     = _Head;
            // _Extracted-&gt;_Parent handled in _Insert_node
            _Extracted-&gt;_Right = _Head;
            _Extracted-&gt;_Color = _Red;

            const auto _Inserted = _Scary-&gt;_Insert_node(_Loc._Location, _Extracted);
            _Reparent_ptr(_Inserted, _That);
        }
    }

    template &lt;class _Other_traits&gt;
    void merge(_Tree&lt;_Other_traits&gt;&amp;&amp; _That) {
        static_assert(is_same_v&lt;_Nodeptr, typename _Tree&lt;_Other_traits&gt;::_Nodeptr&gt;,
            "merge() requires an argument with a compatible node type.");

        static_assert(is_same_v&lt;allocator_type, typename _Tree&lt;_Other_traits&gt;::allocator_type&gt;,
            "merge() requires an argument with the same allocator type.");

        merge(_That);
    }

protected:
    template &lt;class _Other_traits&gt;
    void _Reparent_ptr(const _Nodeptr _Ptr, _Tree&lt;_Other_traits&gt;&amp; _Old_parent) {
        (void) _Ptr;
        (void) _Old_parent;
#if _ITERATOR_DEBUG_LEVEL == 2
        _Lockit _Lock(_LOCK_DEBUG);
        const auto _Old_parent_scary = _Old_parent._Get_scary();
        _Iterator_base12** _Pnext    = &amp;_Old_parent_scary-&gt;_Myproxy-&gt;_Myfirstiter;
        _STL_VERIFY(_Pnext, "source container corrupted");
        if (_Ptr == nullptr || _Ptr == _Old_parent_scary-&gt;_Myhead) {
            return;
        }

        const auto _My_saved_proxy               = _Get_scary()-&gt;_Myproxy;
        _Iterator_base12** const _My_saved_first = &amp;_My_saved_proxy-&gt;_Myfirstiter;

        while (*_Pnext) {
            _Iterator_base12** const _Next = &amp;(*_Pnext)-&gt;_Mynextiter;
            const auto _Iter               = static_cast&lt;const_iterator*&gt;(*_Pnext);
            if (_Iter-&gt;_Ptr == _Ptr) { // reparent the iterator
                *_Pnext            = *_Next;
                _Iter-&gt;_Myproxy    = _My_saved_proxy;
                _Iter-&gt;_Mynextiter = *_My_saved_first;
                *_My_saved_first   = _Iter;
            } else { // skip the iterator
                _Pnext = _Next;
            }
        }
#endif // _ITERATOR_DEBUG_LEVEL == 2
    }

    void _Check_node_allocator(node_type&amp; _Handle) const {
        (void) _Handle;
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(get_allocator() == _Handle._Getal(), "node handle allocator incompatible for insert");
#endif // _ITERATOR_DEBUG_LEVEL == 2
    }
#endif // _HAS_CXX17

<span style = "background-color:#dfd">    void _Alloc_sentinel_and_proxy() {
        const auto _Scary = _Get_scary();
        auto&amp;&amp; _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
        _Container_proxy_ptr&lt;_Alnode&gt; _Proxy(_Alproxy, *_Scary);
        _Scary-&gt;_Myhead = _Node::_Buyheadnode(_Getal());
        _Proxy._Release();
    }</span>

    template &lt;class... _Valty&gt;
<span style = "background-color:#fdd">    _Nodeptr _Buynode(_Valty&amp;&amp;... _Val) {
        return _Node::_Buynode(_Getal(), _Get_scary()-&gt;_Myhead, _STD forward&lt;_Valty&gt;(_Val)...);
    }</span>

    key_compare&amp; _Getcomp() noexcept {
        return _Mypair._Get_first();
    }

<span style = "background-color:#fdd">    const key_compare&amp; _Getcomp() const noexcept {
        return _Mypair._Get_first();
    }</span>

<span style = "background-color:#dfd">    _Alnode&amp; _Getal() noexcept {
        return _Mypair._Myval2._Get_first();
    }</span>

<span style = "background-color:#fdd">    const _Alnode&amp; _Getal() const noexcept {
        return _Mypair._Myval2._Get_first();
    }</span>

<span style = "background-color:#dfd">    _Scary_val* _Get_scary() noexcept {
        return _STD addressof(_Mypair._Myval2._Myval2);
    }</span>

<span style = "background-color:#fdd">    const _Scary_val* _Get_scary() const noexcept {
        return _STD addressof(_Mypair._Myval2._Myval2);
    }</span>

private:
    _Compressed_pair&lt;key_compare, _Compressed_pair&lt;_Alnode, _Scary_val&gt;&gt; _Mypair;
};
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XTREE_</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>